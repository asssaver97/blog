---
title: 【数据库】MySQL
date: 2022-03-06 16:19:16
tags: 数据库
categories: 八股文
---
数据库索引的实现原理（B+树）
---
在介绍B+树之前， 先简单的介绍一下B树。
### B树
#### B树概念
B树也称B-树,它是一颗多路平衡查找树。首先，B树和B+树都是从最简单的二叉树变换而来的，我们来看看B树的定义：
* 每个节点最多有m-1个**关键字**（可以存有的键值对）。
* 根节点最少可以只有1个**关键字**。
* 非根节点至少有m/2个**关键字**。
* 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
* 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
* 每个节点都存有索引和数据，也就是对应的key和value。

所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1。

描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。

#### B树插入
插入的时候，我们需要记住一个规则：**判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。**

例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。

* 插入18，70，50, 40
![](/images/mysql_Binsert1.png)
* 插入22
![](/images/mysql_Binsert2.png)
* 插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下
![](/images/mysql_Binsert3.png)
* 接着插入23，25，39
![](/images/mysql_Binsert4.png)
* 分裂，得到下面的
![](/images/mysql_Binsert5.png)

#### B树删除
B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。

例子：现在有一个初始状态是下面这样的B树，然后进行删除操作。
![](/images/mysql_Bremove1.png)
* 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。
![](/images/mysql_Bremove2.png)
![](/images/mysql_Bremove3.png)
* 接着，我们把22删除，这种情况的规则：22是非叶子节点，**对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。**对于删除22，需要将后继元素24移到被删除的22所在的节点。
![](/images/mysql_Bremove4.png)
![](/images/mysql_Bremove5.png)
* 此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：**如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。**这样就满足要求了。
![](/images/mysql_Bremove6.png)
![](/images/mysql_Bremove7.png)
* 接着删除28，删除叶子节点，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，**首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点。**
![](/images/mysql_Bremove8.png)
![](/images/mysql_Bremove9.png)

### B+树
相同点：
* 根节点至少一个元素
* 非根节点元素范围：m/2 <= k <= m-1

不同点：
* B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
* 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
* 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
* 父节点存有右孩子的第一个元素的索引。

![](/images/mysql_Bplus.png)

#### 插入
对于插入操作很简单，只需要记住一个技巧即可：**当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。**

下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。

* 插入5，10，15，20
![](/images/mysql_Bplusinsert1.png)
* 插入25，此时元素数量大于4个了，分裂
![](/images/mysql_Bplusinsert2.png)
* 接着插入26，30，继续分裂
![](/images/mysql_Bplusinsert3.png)
![](/images/mysql_Bplusinsert4.png)

#### 删除
对于删除操作是比B树简单一些的，因为**叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，**下面我们看看具体的实例。
* 初始状态
![](/images/mysql_Bplusremove1.png)
* 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引
![](/images/mysql_Bplusremove2.png)
* 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引
![](/images/mysql_Bplusremove3.png)
* 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作
![](/images/mysql_Bplusremove4.png)

B和B+树的区别
---
B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

### B+ 树的优点
* B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
* 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。

### B树的优点在于：
由于B树的每一个节点都包含key和value，因此如果经常访问的元素离根节点更近，这种情况下访问也更迅速：
![](/images/mysql5.png)

### 使用B树和B+树的比较
InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
* IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；
* 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
* 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

使用B树索引和哈希索引的比较
---
哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。

使用索引的优点
---
* 大大加快了数据的检索速度；
* 可以显著减少查询中分组和排序的时间；
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
* 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

缺点：建立和维护索引耗费时间空间，更新索引很慢。

哪些情况下索引会失效？
---
* 以`%`(表示任意0个或多个字符)开头的LIKE语句；
* OR语句前后没有同时使用索引；
* 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
* 对于多列索引，必须满足**最左匹配原则**/最左前缀原则 (最左优先：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
* 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

在哪些地方适合创建索引？
---
* 某列经常作为最大最小值；
* 经常被查询的字段；
* 经常用作表连接的字段；
* 经常出现在ORDER BY/GROUP BY/DISTINCT后面的字段

创建索引时需要注意什么？
---
* 只应建立在**小字段**上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；
* 建立索引的字段应该**非空**，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；
* 选择**数据密度大**（唯一值占总数的百分比很大）的字段作索引

索引的分类？
---
* **普通索引**
* **唯一索引** UNIQUE：索引列的值必须唯一，但允许有空值；
* **主键索引** PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；
* **单列索引和多列索引/复合索引**（Composite）：索引的列数；
* **覆盖（Covering）索引：**索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
* **聚集（Clustered）索引/非聚集索引：**对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；
* **虚拟索引（Virtual）：**模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用

MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？
---
* InnoDB**支持事务**，可以进行Commit和Rollback；
* MyISAM 只支持表级锁，而 InnoDB 还**支持行级锁**，提高了并发操作的性能；
* InnoDB **支持外键**；
* MyISAM 崩溃后发生损坏的概率比 InnoDB **高**很多，而且恢复的速度也更**慢**；
* MyISAM 支持压缩表和空间数据索引，InnoDB需要更多的内存和存储；
* InnoDB 支持在线热备份

### 应用场景
* **MyISAM**管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；
* **InnoDB**支持事务，并发情况下有很好的性能，基本可以替代MyISAM

### 热备份和冷备份
* **热备份：**在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错
* **冷备份：**数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单

如何优化数据库？
---
### SQL 语句的优化
* 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL
* 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题；
* 应尽量避免在 where 子句中使用!=、<、>操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描；
* 只返回必要的列：最好不要使用 SELECT * 语句；
* 只返回必要的行：使用 LIMIT 语句来限制返回的数据；
* 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
    * 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；
    * 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；
    * 减少锁竞争

### 索引的优化
注意会引起索引失效的情况，以及在适合的地方建立索引

### 数据库表结构的优化
* 设计表时遵循**三大范式**；
* 选择合适的**数据类型**：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）；
* 表的**水平切分**（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；
* 表的**垂直切分**：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单

### 系统配置的优化
* 操作系统：增加TCP支持的队列数；
* MySQL配置文件优化：缓存池大小和个数设置

### 硬件的优化
* 磁盘性能：固态硬盘；
* CPU：多核且高频；
* 内存：增大内存

什么是主从复制？实现原理是什么？
---
主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。

实现原理：
* **主服务器 binary log dump 线程：**将主服务器中的数据更改（增删改）日志写入 Binary log 中；
* **从服务器 I/O 线程：**负责从主服务器读取binary log，并写入本地的 Relay log；
* **从服务器 SQL 线程：**负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性

### 为什么要主从复制？
* 读写分离：主服务器负责写，从服务器负责读
    * 缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；
    * 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
    * 增加冗余，提高可用性
* 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换
* 降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能

关系型数据库和非关系型数据库的区别？
---
非关系型数据库的优势：
1. 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
2. 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

关系型数据库的优势：
1. 复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
2. 事务支持 使得对于安全性能很高的数据访问要求得以实现。

