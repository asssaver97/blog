---
title: 后台开发面试知识点自查
date: 2022-09-02 20:20:51
tags: 八股文
mathjax: true
categories: 
  - [C++]
  - [数据库]
  - [操作系统]
  - [计算机网络]
  - [算法]
---
C++
---
### C和C++的区别是什么？
#### Answer
网上最常用的两种说法是：C++是C的超集，或者说C是C++的子集、C++面向对象而C面向过程，但我认为这种抽象的说法并不对，C和C++的区别只能从更具体的方向阐述。C++提供了更强大的标准库STL，还有许多纷繁复杂的特性，比如模板、引用、智能指针、auto变量等。

误区一：C是C++的子集

网上这么说是因为C能实现的C++都能实现，而C++支持的C却未必能支持。但其实C++里面很多东西都可以在C里面用稍微别扭一些的方式实现，基本上只有两件事做不到，或者做起来尤其困难：

* 自动的对象作用域以及基于它的生命周期管理
* 模板

而且在一些细节却重要的地方，二者差别很大，比如 C 语言的函数指针：

```c
int (*pfunc)();
```
<!--more-->

看上去`pfunc`可以指向返回值为int，无参数的函数，但实际上`pfunc`可以指向任意返回值为int的函数，无论参数是什么。而无参的情况必须写明参数为`void`：

```c
int (*pfunc)(void);
```

C语言不必指定参数类型也可以引用函数，这一点让C语言具有很强的动态特性。而C++去除了这种设计，因为破坏了类型安全。

同理，C语言常用的(void*)转换在C++中也在很大程度上摒弃了，理由也是类型不安全。比如`int*p = (void*)0;`

误区二：C++是面向对象的语言，C是面向过程的语言

现代C++是至少四种编程范式的集合体——**面向过程，面向对象，泛型编程和元编程，函数式编程**等，实际可能不止4种。说C++是面向对象语言，是一种很瞧不起C++的说法，因为面向对象仅仅是C++的多种范式之一。

在面向对象方面，C语言提供的语法支持比较薄弱，但这不表示C是面向过程的语言，用C语言也可以写面向对象的程序，例如Linux的图形界面GNOME就是用纯C写的。

### C与C++ struct的区别？
#### Answer
||C|C++|
|:---|:---|:---|
|成员函数|不可以|可以|
|静态成员|不可以|可以|
|访问控制|默认public，不能修改|public/private/protected|
|继承关系|不可以|可以从类或其他结构体继承|
|初始化|不可以|可以|

使用时，C需要加上struct关键字，或者用typedef取别名，而C++可以省略struct关键字直接使用，比如：

```cpp
struct Student {
	int age;
	string name;
}
typedef struct Student Student2;  // C中取别名

struct Student stu1;  // C中正常使用
Student2 stu2;  // C中通过取别名使用
Student stu3;  // C++中使用
```

### 强类型、弱类型、静态类型、动态类型的区别是什么？
#### Answer
先上图

![](/images/强弱静态动态类型.png)

* 编译时就知道变量类型的是静态类型；运行时才知道一个变量类型的叫做动态类型。
* 不允许隐式转换的是强类型，允许隐式转换的是弱类型。
 * C++ 里常见的 `auto ite = vec.iterator();` 这种也属于静态类型，这种叫做类型推导，通过已知的类型在编译时期推导出不知道的变量的类型。

弱类型：

```
> "1"+2
'12'
```

强类型：

```
>>> "1"+2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: cannot concatenate 'str' and 'int' objects
```

动态类型：

```
>>> a = 1
>>> type(a)
<type 'int'>
>>> a = "s"
>>> type(a)
<type 'str'>
```

静态类型：

```
Prelude> let a = "123" :: Int

<interactive>:2:9:
    Couldn't match expected type `Int' with actual type `[Char]'
    In the expression: "123" :: Int
    In an equation for `a': a = "123" :: Int
```

### include头文件双引号""和尖括号<>的区别？
#### Answer
1. 尖括号<>的头文件是系统文件，双引号""的头文件是自定义文件。
2. 编译器预处理阶段查找头文件的路径不一样：
  * 使用尖括号<>的头文件的查找路径:编译器设置的头文件路径-->系统变量。
  * 使用双引号""的头文件的查找路径:当前头文件目录-->编译器设置的头文件路径-->系统变 量。

### C++程序编译过程？
#### Answer
编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。

* **编译预处理：**处理以 # 开头的指令；
  1. 将所有的#define删除，并且展开所有的宏定义
  2. 处理所有的条件预编译指令，如#if、#ifdef
  3. 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置
  4. 过滤所有的注释
  5.  添加行号和文件名标识。 
* **编译：**将源码 .cpp 文件翻译成 .s 汇编代码；
  1. 词法分析:将源代码的字符序列分割成一系列的记号。
  2. 语法分析:对记号进行语法分析，产生语法树。
  3. 语义分析:判断表达式是否有意义。
  4. 代码优化
  5. 目标代码生成:生成汇编代码。
  6. 目标代码优化
* **汇编：**将汇编代码 .s 翻译成机器指令 .o 文件；
* **链接：**汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

![](/images/程序编译过程.png)

### 静态链接和动态链接的区别？
#### Answer
* **静态链接：**代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。
* **动态链接：**代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

二者的优缺点：

* **静态链接：**浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。**属于空间换时间。**
* **动态链接：**节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。**属于时间换空间。**

### 静态库和动态库怎么创建？
#### Answer
以MacOS为例：
假设我们有一个util.cpp文件和main.cpp文件，在main文件中调用util.cpp文件中定义的函数。我们把util.cpp文件制作成静态库和动态库。

1. 生成目标文件

 ```
g++ -c util.cpp -o util.o
```

2. 打包静态库

 ```
ar crv libutil.a util.o
```

3. 生成动态库

 ```
g++ -shared -fPIC -o libutil.so util.o
```

4. 使用静态库

 ```
g++ -g main.cpp libutil.a -o a.out
```

5. 使用动态库

 ```
g++ -g -std=c++11 main.cpp -L. -l util -o a.out
```
-L. 意思是在当前目录下(./)寻找库

也可以写到一个makefile文件一键执行

```cpp
target:
	mkdir -p output
	g++ -c util.cpp -o ./output/util.o -std=c++11
	ar crv ./output/libutil.a ./output/util.o
	g++ -shared -fPIC -o ./output/libutil.so ./output/util.o
	rm ./output/util.o
	g++ -g main.cpp ./output/libutil.a -o a.out -std=c++11
	#g++ -g -std=c++11 main.cpp -L./output -l util -o a.out
	rm -rf *.dSYM
clean:
	rm -rf ./output *.out *.dSYM
```


### C++内存布局？
#### Answer
![](/images/内存布局.jpeg)

* **Code Segment（代码区）**

 也称Text Segment，存放可执行程序的机器码。

* **Data Segment (数据区）**

 存放已初始化的全局和静态变量，常量数据（如字符串常量）。

* **BSS（Block started by symbol)**

 存放未初始化的全局和静态变量。（默认设为0）

* **Heap（堆）**

 从低地址向高地址增长。容量大于栈，程序中**动态分配**的内存在此区域。

* **Stack（栈）**

 从高地址向低地址增长。由编译器自动管理分配。程序中的**局部变量、函数参数值、返回变量**等存在此区域。

```cpp
#include <iostream>
using namespace std;

/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/

int g_var = 0; // g_var 在数据区
char *gp_var;  // gp_var 在BSS

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在数据区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在数据区
    static int s_var = 0;       // s_var 为静态变量，存在数据区
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```

### 栈和堆的区别？
####Answer
* 申请方式：栈是系统自动分配，堆是程序员主动申请。
* 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的**首地址存放的是本次分配空间的大小**，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
* 空间分配：栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
* 申请效率：栈是由系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
* 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

### 自由存储区是否等价于堆？
#### Answer
堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的**抽象**概念。在概念上两者并不等价，但是从技术上来说，两者是否等价要取决于`operate new`如何实现，C++编译器默认使用堆来实现自由存储，因为new和delete默认会由mollac和free来实现，但是也可以通过重载操作符来改用其他内存实现自由存储。

### 全局变量、局部变量、静态全局变量、静态局部变量的区别？
####Answer
C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

* 从作用域看：

 * **全局变量：**在所有函数外部声明的变量，称为全局变量。具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他源文件需要用 **extern** 关键字再次声明这个全局变量。
 * **静态全局变量：**具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即**被 static 关键字修饰过的变量具有文件作用域**。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
 * **局部变量：**具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
 * **静态局部变量：**具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，**它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见**。

* 从分配内存空间看：

 * **数据区：**全局变量，静态局部变量，静态全局变量。
 * **栈：**局部变量。

### 全局变量定义在头文件中有什么问题？
#### Answer
如果在头文件中定义全局变量，当该头文件被多个文件`include`时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。

### 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？
#### Answer
C++ 中的类的对象的建立分为两种：静态建立、动态建立。

* **静态建立：**由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;
* **动态建立：**使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();

限制对象只能建立在堆上：

* 最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。

* 解决方法 1：

 将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。

 ```cpp
class A
{
public:
    A() {}
    void destory() {
        delete this;
    }
private:
    ~A() {}
};
```

 该方法存在的问题：

 * 用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 `destory()` 函数，用来释放 new 创建的对象。
 * 无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。

* 解决方法 2：

 构造函数设置为 `protected`，并提供一个 `public` 的静态函数来完成构造，而不是在类的外部使用 `new` 构造；将析构函数设置为 `protected`。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 `create()` 函数在堆上创建对象。

 ```cpp
class A
{
protected:
    A() {}
    ~A() {}
public:
    static A *create()
    {
        return new A();
    }
    void destory()
    {
        delete this;
    }
};
```

限制对象只能建立在栈上：

* 解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。 

 ```cpp
class A
{
private:
    void *operator new(size_t t) {}    // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void *ptr) {} // 重载了 new 就需要重载 delete
public:
    A() {}
    ~A() {}
};
```

### 什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？
#### Answer
内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中

内存对齐的原则：

* 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
* 关于对齐基数，**gcc中默认`#pragma pack(4)`，可以通过预编译命令`#pragma pack(n)`，n = 1,2,4,8,16来改变这一系数。**
* 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；
* 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。

```cpp
/*
说明：程序是在 64 位编译器下测试的
*/
#include <iostream>

using namespace std;

struct A
{
    short var; // 2 字节
    int var1;  // 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8
    long var2; // 12 字节 8 + 4 (long) = 12
    char var3; // 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16
    string s;  // 48 字节 16 + 32 (string) = 48
};

int main()
{
    short var;
    int var1;
    long var2;
    char var3;
    string s;
    A ex1;
    cout << sizeof(var) << endl;  // 2 short
    cout << sizeof(var1) << endl; // 4 int
    cout << sizeof(var2) << endl; // 4 long
    cout << sizeof(var3) << endl; // 1 char
    cout << sizeof(s) << endl;    // 32 string
    cout << sizeof(ex1) << endl;  // 48 struct
    return 0;
}
```

进行内存对齐的原因：（主要是硬件设备方面的问题）

* 某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；
* 某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；
* 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；
* 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；
* 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。

内存对齐的优点：

* 便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；
* 提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。

### 怎么计算类的大小？
#### Answer
类的大小是指类的实例化对象的大小，用 `sizeof` 对类型名操作时，结果是该类型的对象的大小。

计算原则：

* 遵循结构体的对齐原则。
* 与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。
* 虚函数对类的大小有影响，是因为虚函数表指针的影响。
* 虚继承对类的大小有影响，是因为虚基表指针带来的影响。
* 空类的大小是一个特殊情况，**空类的大小为 1**，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。

```cpp
/*
说明：程序是在 64 位编译器下测试的
*/
#include <iostream>

using namespace std;

class A
{
private:
    static int s_var; // 不影响类的大小
    const int c_var;  // 4 字节
    int var;          // 8 字节 4 + 4 (int) = 8
    char var1;        // 12 字节 8 + 1 (char) + 3 (填充) = 12
public:
    A(int temp) : c_var(temp) {} // 不影响类的大小
    ~A() {}                    // 不影响类的大小
};

class B
{
};
int main()
{
    A ex1(4);
    B ex2;
    cout << sizeof(ex1) << endl; // 12 字节
    cout << sizeof(ex2) << endl; // 1 字节
    return 0;
}
```

带有虚函数的情况：**（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。）**

```cpp
/*
说明：程序是在 64 位编译器下测试的
*/
#include <iostream>

using namespace std;

class A
{
private:
    static int s_var; // 不影响类的大小
    const int c_var;  // 4 字节
    int var;          // 8 字节 4 + 4 (int) = 8
    char var1;        // 12 字节 8 + 1 (char) + 3 (填充) = 12
public:
    A(int temp) : c_var(temp) {} // 不影响类的大小
    ~A() {}                      // 不影响类的大小
    virtual void f() { cout << "A::f" << endl; }

    virtual void g() { cout << "A::g" << endl; }

    virtual void h() { cout << "A::h" << endl; } // 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24
};

int main()
{
    A ex1(4);
    A *p;
    cout << sizeof(p) << endl;   // 8 字节 注意：指针所占的空间和指针指向的数据类型无关
    cout << sizeof(ex1) << endl; // 24 字节
    return 0;
}
```

### 什么是内存泄露？
#### Answer
**内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。** 进一步解释：

* 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。
* 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。
* 使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。
* 指针重新赋值

 ```cpp
char *p = (char *)malloc(10);
char *p1 = (char *)malloc(10);
p = p1;
```
开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。

### 怎么防止内存泄漏？内存泄漏检测工具的原理？
#### Answer
**智能指针**

* 智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用
* 智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了头文件`<memory>`中。

### 智能指针有哪几种？
#### Answer
C++ 标准模板库 STL（Standard Template Library） 一共给我们提供了四种智能指针：**auto_ptr**、**unique_ptr**、**shared_ptr** 和 **weak_ptr**，其中 **auto_ptr** 是 C++98 提出的，C++11 已将其摒弃，并提出了 **unique_ptr** 替代 **auto_ptr**。

* **共享指针**（shared\_ptr）：《Effective C++》称之为“引用计数型智能指针”，资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 `use_count()` 查看资源的所有者的个数，可以通过 weak\_ptr 来构造，调用 `release()` 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。
* **独占指针**（unique\_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 `move()` 函数），即一个 unique\_ptr 对象赋值给另一个 unique\_ptr 对象，可以通过该方法进行赋值。
* **弱指针**（weak\_ptr）：指向 share\_ptr 指向的对象，能够解决由shared\_ptr带来的循环引用问题。使用 weak\_ptr 的成员函数 `use_count()` 可以观测资源的引用计数，另一个成员函数 `expired()` 的功能等价于 `use_count()==0`，但更快，表示被观测的资源（也就是 shared\_ptr 管理的资源）已经不复存在。weak\_ptr 可以使用一个非常重要的成员函数`lock()`从被观测的 shared\_ptr 获得一个可用的 shared\_ptr 管理的对象， 从而操作资源。但当 `expired()==true` 的时候，`lock() `函数将返回一个存储空指针的 shared\_ptr。

### shared\_ptr和unique\_ptr的区别？
#### Answer
shared\_ptr允许多个指针指向同一个对象，而unique\_ptr 独占所指向的对象。与shared\_ptr不同，某个时刻只能有一个unique\_ptr指向一个给定对象。当unique\_ptr被销毁时，它所指向的对象也被销毁。

#### shared_ptr类

```cpp
shared_ptr<string> p1;      //可以指向string
shared_ptr<list<int>> p2;   //可以指向int的list
```

**make_shared函数**
最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的`shared_ptr`。

当要用make\_shared时，必须指定想要创建的对象的类型，如下：

```cpp
//指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
//p4指向一个值为"9999999999"的string
shared_ptr<string> p4 = make_shared<string>(10,'9');
//p5指向一个值初始化的int,值为0
shared_ptr<int> p5 = make_shared<int>();
```

也可以使用auto定义一个对象来保存make\_shared的结果，更为简单：

```cpp
//p6指向一个动态分配的空vector<string>
auto p6 = make_shared<vector<string>>();
```

当进行拷贝或赋值操作时，每个shared\_ptr都会记录有多少个其他shared\_ptr指向相同的对象：

```cpp
auto p = make_shared<int>(42);      //p指向的对象只有p一个引用者
auto q(p);                         //p和q指向相同对象，此对象有两个引用者    
```

我们可以认为每个shared\_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。

#### unique_ptr类
与shared\_ptr不同，没有类似make_shared的标准库函数返回一个unique\_ptr。所以初始化unique\_ptr必须采用直接初始化形式，如下：

```cpp
unique_ptr<double> p1;      //可以指向一个double的unique_ptr
unique_ptr<int> p2(new int(42));    //p2指向一个值为42的int
```

### 实现一个shared_ptr。
#### Answer
计数原理。

```cpp
#include <iostream>
#include <memory>

template <typename T>
class SmartPtr {
private : 
	T *_ptr;
	size_t *_count;

public:
	SmartPtr(T *ptr = nullptr) : _ptr(ptr) {
		if (_ptr) {
			_count = new size_t(1);
		} else {
			_count = new size_t(0);
		}
	}

	~SmartPtr() {
		(*this->_count)--;
		if (*this->_count == 0) {
			delete this->_ptr;
			delete this->_count;
		}
	}

	SmartPtr(const SmartPtr &ptr) { // 拷贝构造：计数 +1
		if (this != &ptr) {
			this->_ptr = ptr._ptr;
			this->_count = ptr._count;
			(*this->_count)++;
		}
	}

	SmartPtr &operator=(const SmartPtr &ptr) { // 赋值运算符重载 
		if (this->_ptr == ptr._ptr) {
			return *this;
		}
		if (this->_ptr) { // 将当前的 ptr 指向的原来的空间的计数 -1
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
		this->_ptr = ptr._ptr;
		this->_count = ptr._count;
		(*this->_count)++; // 此时 ptr 指向了新赋值的空间，该空间的计数 +1
		return *this;
	}

	T &operator*() {
		assert(this->_ptr == nullptr);
		return *(this->_ptr);
	}

	T *operator->() {
		assert(this->_ptr == nullptr);
		return this->_ptr;
	}

	size_t use_count() {
		return *this->count;
	}
};
```

### 一个独占指针（unique\_ptr）怎么赋值给另一个独占指针（unique\_ptr）对象？
#### Answer
借助 std::move() 可以实现将一个 unique\_ptr 对象赋值给另一个 unique\_ptr 对象，其目的是实现所有权的转移。

```cpp
// A 作为一个类 
std::unique_ptr<A> ptr1(new A());
std::unique_ptr<A> ptr2 = std::move(ptr1);
```

### 使用智能指针会出现什么问题？怎么解决？
#### Answer
智能指针可能出现的问题：**循环引用。**
在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。

```cpp
#include <iostream>
#include <memory>

using namespace std;

class Child;
class Parent;

class Parent {
private:
    shared_ptr<Child> ChildPtr;
public:
    void setChild(shared_ptr<Child> child) {
        this->ChildPtr = child;
    }

    void doSomething() {
        if (this->ChildPtr.use_count()) {

        }
    }

    ~Parent() {
    }
};

class Child {
private:
    shared_ptr<Parent> ParentPtr;
public:
    void setPartent(shared_ptr<Parent> parent) {
        this->ParentPtr = parent;
    }
    void doSomething() {
        if (this->ParentPtr.use_count()) {

        }
    }
    ~Child() {
    }
};

int main() {
    weak_ptr<Parent> wpp;
    weak_ptr<Child> wpc;
    {
        shared_ptr<Parent> p(new Parent);
        shared_ptr<Child> c(new Child);
        p->setChild(c);
        c->setPartent(p);
        wpp = p;
        wpc = c;
        cout << p.use_count() << endl; // 2
        cout << c.use_count() << endl; // 2
    }
    cout << wpp.use_count() << endl;  // 1
    cout << wpc.use_count() << endl;  // 1
    return 0;
}
```

**循环引用的解决方法：weak_ptr**

循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。

* weak_ptr 对被 shared_ptr 管理的对象存在 非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr；
* weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；
* weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。

```cpp
#include <iostream>
#include <memory>

using namespace std;

class Child;
class Parent;

class Parent {
private:
    //shared_ptr<Child> ChildPtr;
    weak_ptr<Child> ChildPtr;
public:
    void setChild(shared_ptr<Child> child) {
        this->ChildPtr = child;
    }

    void doSomething() {
        //new shared_ptr
        if (this->ChildPtr.lock()) {

        }
    }

    ~Parent() {
    }
};

class Child {
private:
    shared_ptr<Parent> ParentPtr;
public:
    void setPartent(shared_ptr<Parent> parent) {
        this->ParentPtr = parent;
    }
    void doSomething() {
        if (this->ParentPtr.use_count()) {

        }
    }
    ~Child() {
    }
};

int main() {
    weak_ptr<Parent> wpp;
    weak_ptr<Child> wpc;
    {
        shared_ptr<Parent> p(new Parent);
        shared_ptr<Child> c(new Child);
        p->setChild(c);
        c->setPartent(p);
        wpp = p;
        wpc = c;
        cout << p.use_count() << endl; // 2
        cout << c.use_count() << endl; // 1
    }
    cout << wpp.use_count() << endl;  // 0
    cout << wpc.use_count() << endl;  // 0
    return 0;
}
```

### C++11 有哪些新特性？
#### Answer
1. **auto 类型推导关键字：**自动类型推导，编译器会在 **编译期间** 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。
2. **decltype 类型推导关键字：**decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在**编译期间**进行自动类型推导。**如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。**和auto的区别如下：

 ```cpp
auto var = val1 + val2; 
decltype(val1 + val2) var1 = 0; 
```

3. **lambda 表达式（匿名函数）**

 ```cpp
 [capture list] (parameter list) -> return type
{
   function body;
};
```

4. **范围for语句**

 ```cpp
 for (declaration : expression){
    statement
}
```

5. **右值引用、移动语义、完美转发**

 [看我另一篇博文——C++右值引用](http://wangtianyang.com/2022/09/02/%E3%80%90C-%E3%80%91%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/)
 
6. **智能指针**
7. **delete 函数和 default 函数**
 * delete 函数：= delete 表示该函数不能被调用。
 * default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。

 例子：

 ```cpp
 #include <iostream>
using namespace std;

class A
{ß
public:
	A() = default; // 表示使用默认的构造函数
	~A() = default;	// 表示使用默认的析构函数
	A(const A &) = delete; // 表示类的对象禁止拷贝构造
	A &operator=(const A &) = delete; // 表示类的对象禁止拷贝赋值
};
int main()
{
	A ex1;
	A ex2 = ex1; // error: use of deleted function 'A::A(const A&)'
	A ex3;
	ex3 = ex1; // error: use of deleted function 'A& A::operator=(const A&)'
	return 0;
}
```

### 什么是面向对象？面向对象的三大特性？
#### Answer
面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。

面向对象的三大特性：

* 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。
* 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。
* 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

### 重载、重写/覆盖、重定义/隐藏的区别？
#### Answer
* 重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须**至少**有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部，不能跨作用域。

* 重定义：也叫做隐藏，子类重新定义父类中有相同名称的**非虚函数** ( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。

* 重写：也叫做覆盖（override），一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的**虚函数**。(访问修饰符可以不同)

### 什么是多态？多态如何实现？
#### Answer
多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。 实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。

**实现过程：**

* 在类中用 virtual 关键字声明的函数叫做虚函数；
* 存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；
* 当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。

举例：

```cpp
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void fun() { cout << "Base::fun()" << endl; }

	virtual void fun1() { cout << "Base::fun1()" << endl; }

	virtual void fun2() { cout << "Base::fun2()" << endl; }
};
class Derive : public Base
{
public:
	void fun() { cout << "Derive::fun()" << endl; }

	virtual void D_fun1() { cout << "Derive::D_fun1()" << endl; }

	virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
};
int main()
{
	Base *p = new Derive();
	p->fun(); // Derive::fun() 调用派生类中的虚函数
	return 0;
}
```

基类的虚函数表如下：

![](/images/基类虚函数表.png)

派生类的对象虚函数表如下：

![](/images/派生类虚函数表.png)

简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数`Derive::f()`进行调用。

### strlen和sizeof的区别？
#### Answer
1. `strlen`测量的是字符串的实际长度（其源代码如下），以`\0`结束。而`sizeof`测量的是字符数组的分配大小。

 ```cpp
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char arr[10] = "hello";
    cout << strlen(arr) << endl; // 5
    cout << sizeof(arr) << endl; // 10
    return 0;
}
```

2. 若字符数组 arr 作为**函数的形参**，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。

 ```cpp
#include <iostream>
#include <cstring>

using namespace std;

void size_of(char arr[])
{
    cout << sizeof(arr) << endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' .
    cout << strlen(arr) << endl; 
}

int main()
{
    char arr[20] = "hello";
    size_of(arr); 
    return 0;
}
/*
输出结果：
8
5
*/
```

3. `strlen`本身是库函数，因此在程序运行过程中，计算长度；而`sizeof`在编译时，计算长度；
4. `sizeof`的参数可以是类型，也可以是变量；`strlen`的参数必须是`char*`类型的变量。

### lambda 表达式（匿名函数）的具体应用和使用场景
#### Answer
lambda 表达式的定义形式如下：

```cpp
[capture list] (parameter list) -> reurn type
{
   function body
}
```

其中：

* capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&]、值捕获方式 [=]。
* return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。

举例：`lambda`表达式常搭配排序算法使用。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {3, 4, 76, 12, 54, 90, 34};
    sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; }); // 降序排序
    for (auto a : arr) {
        cout << a << " ";
    }
    return 0;
}
/*
运行结果：90 76 54 34 12 4 3
*/
```

### explicit 的作用（如何避免编译器进行隐式类型转换）
#### Answer
作用：用来声明类构造函数是显式调用[^1]的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上`explicit`关键字也没有什么意义。

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class A {
public:
    int var;
    A(int tmp) {
        var = tmp;
    }
};
int main() {
    A ex = 10; // 发生了隐式转换
    return 0;
}
```

上述代码中，`A ex = 10;`在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：
为了避免隐式转换，可用 `explicit` 关键字进行声明：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    explicit A(int tmp)
    {
        var = tmp;
        cout << var << endl;
    }
};
int main()
{
    A ex(100);
    A ex1 = 10; // error: conversion from 'int' to non-scalar type 'A' requested
    return 0;
}
```

### static 的作用
#### Answer
作用：`static` 定义静态变量，静态函数。

* 保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。

 ```cpp
#include <iostream>
using namespace std;

int fun(){
    static int var = 1; // var 只在第一次进入这个函数的时初始化
    var += 1;
    return var;
}
  
int main()
{
    for(int i = 0; i < 10; ++i)
    	cout << fun() << " "; // 2 3 4 5 6 7 8 9 10 11
    return 0;
}
```

* 隐藏：static 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）
* static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。**注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。**

 ```cpp
#include<iostream>
using namespace std;

class A
{
private:
    int var;
    static int s_var; // 静态成员变量
public:
    void show()
    {
        cout << s_var++ << endl;
    }
    static void s_show()
    {
        cout << s_var << endl;
		// cout << var << endl; // error: invalid use of member 'A::a' in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var
        // show();  // error: cannot call member function 'void A::show()' without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show()
    }
};
int A::s_var = 1;  // 静态成员变量在类外进行初始化赋值，默认初始化为 0

int main()
{
    
    // cout << A::s_var << endl;    // error: 'int A::sa' is private within this context
    A ex;
    ex.show();
    A::s_show();
}
```

### static 在类中使用的注意事项（定义、初始化和使用）
#### Answer
* static 静态成员变量：
 1. 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和private、public、protected 访问规则。
 2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，**包括派生类的对象**。
 3. 静态成员变量可以作为成员函数的参数，而普通成员变量不可以。

     ```cpp
#include <iostream>
using namespace std;

class A
{
public:
    static int s_var;
    int var;
    void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数
    void fun2(int i = var);   //  error: invalid use of non-static data member 'A::var'
};
int main()
{
    return 0;
}
```

 4. **静态数据成员的类型可以是所属类的类型**，而普通数据成员的类型只能是该类类型的指针或引用。
 
    ```cpp
#include <iostream>
using namespace std;

class A
{
public:
    static A s_var; // 正确，静态数据成员
    A var;          // error: field 'var' has incomplete type 'A'
    A *p;           // 正确，指针
    A &var1;        // 正确，引用
};

int main()
{
    return 0;
}
```

* static 静态成员函数：
 1. **静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。**静态成员函数做为类作用域的全局函数。
 2. 静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。

### static 全局变量和普通全局变量的异同？
#### Answer
相同点：

* 存储方式：普通全局变量和 static 全局变量都是静态存储方式。

不同点：

* 作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。
* 初始化：静态全局变量只初始化一次，防止在其他文件中使用。

### const 作用及用法
#### Answer
作用：

* `const` 修饰成员变量，定义成 `const` 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。
* `const` 修饰函数参数，使得传递过来的函数参数的值不能改变。
* `const` 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量

在类中的用法：

* const 成员变量：
	1. const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。
	2. const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。

* const 成员函数：
	1. 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。
	2. 不能调用非常量成员函数，以防修改成员变量的值。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	int var;
	A(int tmp) : var(tmp) {}
	void c_fun(int tmp) const // const 成员函数
	{
		var = tmp; // error: assignment of member 'A::var' in read-only object. 在 const 成员函数中，不能修改任何类成员变量。		
		fun(tmp); // error: passing 'const A' as 'this' argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
	}

	void fun(int tmp)
	{
		var = tmp;
	}
};

int main()
{
    return 0;
}
```

### define 和 const 的区别？
#### Answer
区别：

* 编译阶段：define 是在预编译阶段进行替换，const 是在编译阶段确定其值。
* 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。
* 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。
* 调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。

const 的优点：

* 有数据类型，在定义式可进行安全性检查。
* 可调试。
* 占用较少的空间。

### define 和 typedef 的区别？
#### Answer

* **原理：**`#define`作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。`typedef`是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用`typedef`。
* **功能：**`typedef`用来定义类型的别名，方便使用。`#define`不仅可以为类型取别名，还可以定义常量、变量、编译开关等。
* **作用域：**`#define`没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而`typedef`有自己的作用域。
* **指针的操作：**`typedef`和`#define`在处理指针时不完全一样。
```cpp
#include <iostream>
#define INTPTR1 int *
typedef int * INTPTR2;

using namespace std;

int main()
{
    INTPTR1 p1, p2; // p1: int *; p2: int
    INTPTR2 p3, p4; // p3: int *; p4: int *

    int var = 1;
    const INTPTR1 p5 = &var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。
    const INTPTR2 p6 = &var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。
    
    return 0;
}
```

### inline 作用及使用方法
#### Answer
**作用：** inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。

**使用方法：**
1. **类内定义成员函数默认是内联函数：**在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：
```cpp
#include <iostream>
using namespace std;

class A{
public:
    int var;
    A(int tmp){ 
      var = tmp;
    }    
    void fun(){ 
        cout << var << endl;
    }
};

int main()
{    
    return 0;
}
```
2. 类外定义成员函数，若想定义为内联函数，需用关键字声明：当**在类内声明函数，在类外定义函数时**，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。
```cpp
#include <iostream>
using namespace std;

class A{
public:
    int var;
    A(int tmp){ 
      var = tmp;
    }    
    void fun();
};

inline void A::fun(){
    cout << var << endl;
}

int main()
{    
    return 0;
}
```
另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。

**工作原理：**
* 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。
* 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。

### 宏定义（define）和内联函数（inline）的区别
#### Answer
* 内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
* 内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。
* 宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。

### new 和 malloc 如何判断是否申请到内存？
#### Answer
* malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。
* new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bad_alloc 异常。

### delete 实现原理？delete 和 delete[] 的区别？
#### Answer
delete 的实现原理：
* 首先执行该对象所属类的析构函数；
* 进而通过调用 `operator delete()` 的标准库函数来释放所占的内存空间。

delete 和 delete [] 的区别：
* delete 用来释放单个对象所占的空间，只会调用一次析构函数；
* delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。

### new 和 malloc 的区别？delete 和 free 的区别？
#### Answer
在使用的时候`new`、`delete`搭配使用，`malloc`、`free`搭配使用。
* `malloc`、`free`是库函数，而`new`、`delete`是关键字。`new`申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；`malloc`在申请空间时，需要确定所申请空间的大小。
* `new`申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；`malloc`申请空间时，返回的是`void*`类型，需要进行强制类型的转换，转换为对象类型的指针。
* `new`分配失败时，会抛出`bad_alloc`异常，`malloc`分配失败时返回空指针。
* 对于自定义的类型，`new`首先调用`operator new()`函数申请空间（底层通过`malloc`实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；`delete`首先调用析构函数，然后调用`operator delete()`释放空间（底层通过`free`实现）。`malloc`、`free`无法进行自定义类型的对象的构造和析构。
* `new`操作符从自由存储区上为对象动态分配内存，而`malloc`函数从堆上动态分配内存。（自由存储区不等于堆）

### malloc 的原理？malloc 的底层实现？
#### Answer
`malloc`的原理:
* 当开辟的空间小于 128K 时，调用`brk()`函数，通过移动`_enddata`来实现；
* 当开辟空间大于 128 K 时，调用`mmap()`函数，通过在虚拟地址空间中开辟一块内存空间来实现。

`malloc`的底层实现：
* `brk()`函数实现原理：向高地址的方向移动指向数据段的高地址的指针`_enddata`。
* `mmap`内存映射原理：
    1. 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；
    2. 调用内核空间的系统调用函数`mmap()`，实现文件物理地址和进程虚拟地址的一一映射关系；
    3. 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。

### struct 和 union 的区别？
#### Answer
说明：union 是联合体，struct 是结构体。
区别：
1. 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。
2. 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。
3. 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。
```cpp
#include <iostream>
using namespace std;

typedef union
{
    char c[10];
    char cc1; // char 1 字节，按该类型的倍数分配大小
} u11;

typedef union
{
    char c[10];
    int i; // int 4 字节，按该类型的倍数分配大小
} u22;

typedef union
{
    char c[10];
    double d; // double 8 字节，按该类型的倍数分配大小
} u33;

typedef struct s1
{
    char c;   // 1 字节
    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节
} s11;

typedef struct s2
{
    char c;   // 1 字节
    char cc;  // 1（char）+ 1（char）= 2 字节
    double d; // 2 + 6（内存对齐）+ 8（double）= 16 字节
} s22;

typedef struct s3
{
    char c;   // 1 字节
    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节
    char cc;  // 16 + 1（char）+ 7（内存对齐）= 24 字节
} s33;

int main()
{
    cout << sizeof(u11) << endl; // 10
    cout << sizeof(u22) << endl; // 12
    cout << sizeof(u33) << endl; // 16
    cout << sizeof(s11) << endl; // 16
    cout << sizeof(s22) << endl; // 16
    cout << sizeof(s33) << endl; // 24

    cout << sizeof(int) << endl;    // 4
    cout << sizeof(double) << endl; // 8
    return 0;
}
```

### class 和 struct 的异同？
#### Answer
* `struct`和`class`都可以自定义数据类型，也支持继承操作。
* `struct`中默认的访问级别是`public`，默认的继承级别也是`public`；`class`中默认的访问级别是`private`，默认的继承级别也是`private`。
* 当`class`继承`struct`或者`struct`继承`class`时，默认的继承级别取决于`class`或`struct`本身，`class`（private 继承），`struct`（public 继承），**即取决于派生类的默认继承级别。**
```cpp
struct A{}；
class B : A{}; // private 继承 
struct C : B{}； // public 继承
```
举例：
```cpp
#include<iostream>

using namespace std;

class A{
public:
    void funA(){
        cout << "class A" << endl;
    }
};

struct B: A{ // 由于 B 是 struct，A 的默认继承级别为 public
public:
    void funB(){
        cout << "class B" << endl;
    }
};

class C: B{ // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数

};

int main(){
    A ex1;
    ex1.funA(); // class A

    B ex2;
    ex2.funA(); // class A
    ex2.funB(); // class B

    C ex3;
    ex3.funB(); // error: 'B' is not an accessible base of 'C'.
    return 0;
}
```

### volatile 的作用？是否具有原子性，对编译器有什么影响？
#### Answer
`volatile`的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 `violatile`，告知编译器不应对这样的对象进行优化。
`volatile`不具有原子性。
`volatile`对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。

### 什么情况下一定要用 volatile， 能否和 const 一起使用？
#### Answer
使用`volatile`关键字的场景：
* 当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用`volatile`关键字对该变量进行修饰；
* 中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用`volatile`关键字修饰。

`volatile`关键字和`const`关键字可以同时使用，某种类型可以既是`volatile`又是`const`，同时具有二者的属性。

### 返回函数中静态变量的地址会发生什么？
#### Answer
```cpp
#include <iostream>
using namespace std;

int * fun(int tmp){
    static int var = 10;
    var *= tmp;
    return &var;
}

int main() {
    cout << *fun(5) << endl;
    return 0;
}

/*
运行结果：
50
*/
```
说明：上述代码中在函数`fun`中定义了静态局部变量`var`，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。

### extern C 的作用？
#### Answer
当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即`extern "C"`指出任意非 C++ 函数所用的语言。

举例：
```cpp
// 可能出现在 C++ 头文件<cstring>中的链接指示
extern "C"{
    int strcmp(const char*, const char*);
}
```

### sizeof(1==1) 在 C 和 C++ 中分别是什么结果？
#### Answer
C 语言代码：
```cpp
#include<stdio.h>

void main(){
    printf("%d\n", sizeof(1==1));
}

/*
运行结果：
4
*/
```
C++ 代码：
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << sizeof(1==1) << endl;
    return 0;
}

/*
1
*/
```

### memmove函数的底层原理？
#### Answer
```cpp
void *memcpy(void *dst, const void *src, size_t size)
{
    char *psrc;
    char *pdst;

    if (NULL == dst || NULL == src)
    {
        return NULL;
    }

    if ((src < dst) && (char *)src + size > (char *)dst) // 出现地址重叠的情况，自后向前拷贝
    {
        psrc = (char *)src + size - 1;
        pdst = (char *)dst + size - 1;
        while (size--)
        {
            *pdst-- = *psrc--;
        }
    }
    else
    {
        psrc = (char *)src;
        pdst = (char *)dst;
        while (size--)
        {
            *pdst++ = *psrc++;
        }
    }

    return dst;
}
```

### strcpy 函数有什么缺陷？
#### Answer
strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    int var = 0x11112222;
    char arr[10];
    cout << "Address : var " << &var << endl;
    cout << "Address : arr " << &arr << endl;
    strcpy(arr, "hello world!");
    cout << "var:" << hex << var << endl; // 将变量 var 以 16 进制输出
    cout << "arr:" << arr << endl;
    return 0;
}

/*
Address : var 0x23fe4c
Address : arr 0x23fe42
var:11002164
arr:hello world!
*/
```
说明：从上述代码中可以看出，变量`var`的后六位被字符串`"hello world!"`的`"d!\0"`这三个字符改变，这三个字符对应的 ASCII 码的十六进制为：`\0`(0x00)，`!`(0x21)，`d`(0x64)。 原因：变量`arr`只分配的 10 个内存空间，通过上述程序中的地址可以看出`arr`和`var`在内存中是连续存放的，但是在调用`strcpy`函数进行拷贝时，源字符串`"hello world!"`所占的内存空间为 13，因此在拷贝的过程中会占用`var`的内存空间，导致`var`的后六位被覆盖。

### auto 类型推导的原理
#### Answer
`auto`类型推导的原理： 编译器根据初始值来推算变量的类型，要求用`auto`定义变量时必须有初始值。编译器推断出来的`auto`类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。

[^1]:显示调用和隐式调用：显示调用是指在程序中能找到相应的调用代码，或者说是手动调用的；隐式调用是指程序中找不到相应的调用代码，或者说是编译器自动调用的


### 什么是虚函数？什么是纯虚函数？
#### Answer
**虚函数：**被 virtual 关键字修饰的成员函数，就是虚函数。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
    virtual void v_fun() // 虚函数
    {
        cout << "A::v_fun()" << endl;
    }
};
class B : public A
{
public:
    void v_fun()
    {
        cout << "B::v_fun()" << endl;
    }
};
int main()
{
    A *p = new B();
    p->v_fun(); // B::v_fun()
    return 0;
}
```

**纯虚函数：**

* 纯虚函数在类中声明时，加上`=0`；
* 含有纯虚函数的类称为抽象类（**只要含有纯虚函数这个类就是抽象类**），类中只有接口，没有具体的实现方法；
* **继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。**

说明：

* 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；
* 可以声明抽象类指针，可以声明抽象类的引用；
* 子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。

### 虚函数和纯虚函数的区别？
#### Answer
* 虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）
* 使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；
* 定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上`=0`;
* 纯虚函数必须实现，否则编译器会报错；
* 对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；
* 析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。

### 虚函数的实现机制
#### Answer
虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。

**虚函数表相关知识点：**

* 虚函数表存放的内容：类的虚函数的地址。
* 虚函数表建立的时间：**编译阶段**，即程序的编译过程中会将虚函数的地址放在虚函数表中。
* 虚函数表保存的位置：常量区。
* 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。
* 虚函数表和类绑定，虚表指针和对象绑定。即**类的不同的对象的虚函数表是一样的**，但是每个对象都有自己的虚表指针，来指向类的虚函数表。

实例

```cpp
#include <iostream>
using namespace std;

class Base
{
public:
    virtual void B_fun1() { cout << "Base::B_fun1()" << endl; }
    virtual void B_fun2() { cout << "Base::B_fun2()" << endl; }
    virtual void B_fun3() { cout << "Base::B_fun3()" << endl; }
};

class Derive : public Base
{
public:
    virtual void D_fun1() { cout << "Derive::D_fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};
int main()
{
    Base *p = new Derive();
    p->B_fun1(); // Base::B_fun1()
    return 0;
}
```
基类和派生类的继承关系：
![](/images/基类和派生类的继承关系.png)
基类的虚函数表：
![](/images/基类的虚函数表.png)
派生类的虚函数表：
![](/images/派生类的虚函数表.png)
主函数中基类的指针`p`指向了派生类的对象，当调用函数`B_fun1()`时，通过派生类的虚函数表找到该函数的地址，从而完成调用。

### 单继承和多继承的虚函数表结构
#### Answer
**编译器处理虚函数表：**

* 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。
* 如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。
* 如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说**虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中**。
* 如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。

1. 单继承无虚函数覆盖的情况：
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
    virtual void B_fun1() { cout << "Base::B_fun1()" << endl; }
    virtual void B_fun2() { cout << "Base::B_fun2()" << endl; }
    virtual void B_fun3() { cout << "Base::B_fun3()" << endl; }
};

class Derive : public Base
{
public:
    virtual void D_fun1() { cout << "Derive::D_fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};
int main()
{
    Base *p = new Derive();
    p->B_fun1(); // Base::B_fun1()
    return 0;
}
```
基类和派生类的继承关系：
![](/images/类相关图4.png)
基类的虚函数表：
![](/images/类相关图5.png)
派生类的虚函数表：
![](/images/类相关图6.png)
2. 单继承有虚函数覆盖的情况：
```cpp
#include <iostream>
using namespace std;

class Base
{
public:
    virtual void fun1() { cout << "Base::fun1()" << endl; }
    virtual void B_fun2() { cout << "Base::B_fun2()" << endl; }
    virtual void B_fun3() { cout << "Base::B_fun3()" << endl; }
};

class Derive : public Base
{
public:
    virtual void fun1() { cout << "Derive::fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};
int main()
{
    Base *p = new Derive();
    p->fun1(); // Derive::fun1()
    return 0;
}
```
派生类的虚函数表：
![](/images/类相关图7.png)
3. 多继承无虚函数覆盖的情况：
```cpp
#include <iostream>
using namespace std;

class Base1
{
public:
    virtual void B1_fun1() { cout << "Base1::B1_fun1()" << endl; }
    virtual void B1_fun2() { cout << "Base1::B1_fun2()" << endl; }
    virtual void B1_fun3() { cout << "Base1::B1_fun3()" << endl; }
};
class Base2
{
public:
    virtual void B2_fun1() { cout << "Base2::B2_fun1()" << endl; }
    virtual void B2_fun2() { cout << "Base2::B2_fun2()" << endl; }
    virtual void B2_fun3() { cout << "Base2::B2_fun3()" << endl; }
};
class Base3
{
public:
    virtual void B3_fun1() { cout << "Base3::B3_fun1()" << endl; }
    virtual void B3_fun2() { cout << "Base3::B3_fun2()" << endl; }
    virtual void B3_fun3() { cout << "Base3::B3_fun3()" << endl; }
};

class Derive : public Base1, public Base2, public Base3
{
public:
    virtual void D_fun1() { cout << "Derive::D_fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};

int main(){
    Base1 *p = new Derive();
    p->B1_fun1(); // Base1::B1_fun1()
    return 0;
}
```
基类和派生类的关系：
![](/images/类相关图8.png)
派生类的虚函数表：（基类的顺序和声明的顺序一致）
![](/images/类相关图9.png)
4. 多继承有虚函数覆盖的情况：
```cpp
#include <iostream>
using namespace std;

class Base1
{
public:
    virtual void fun1() { cout << "Base1::fun1()" << endl; }
    virtual void B1_fun2() { cout << "Base1::B1_fun2()" << endl; }
    virtual void B1_fun3() { cout << "Base1::B1_fun3()" << endl; }
};
class Base2
{
public:
    virtual void fun1() { cout << "Base2::fun1()" << endl; }
    virtual void B2_fun2() { cout << "Base2::B2_fun2()" << endl; }
    virtual void B2_fun3() { cout << "Base2::B2_fun3()" << endl; }
};
class Base3
{
public:
    virtual void fun1() { cout << "Base3::fun1()" << endl; }
    virtual void B3_fun2() { cout << "Base3::B3_fun2()" << endl; }
    virtual void B3_fun3() { cout << "Base3::B3_fun3()" << endl; }
};

class Derive : public Base1, public Base2, public Base3
{
public:
    virtual void fun1() { cout << "Derive::fun1()" << endl; }
    virtual void D_fun2() { cout << "Derive::D_fun2()" << endl; }
    virtual void D_fun3() { cout << "Derive::D_fun3()" << endl; }
};

int main(){
    Base1 *p1 = new Derive();
    Base2 *p2 = new Derive();
    Base3 *p3 = new Derive();
    p1->fun1(); // Derive::fun1()
    p2->fun1(); // Derive::fun1()
    p3->fun1(); // Derive::fun1()
    return 0;
}
```
基类和派生类的关系：
![](/images/类相关图10.png)
派生类的虚函数表：
![](/images/类相关图11.png)

### 如何禁止构造函数的使用？
#### Answer
为类的构造函数增加`= delete`修饰符，可以达到虽然声明了构造函数但禁止使用的目的。

```cpp
#include <iostream>

using namespace std;

class A {
public:
    int var1, var2;
    A(){
        var1 = 10;
        var2 = 20;
    }
    A(int tmp1, int tmp2) = delete;
};

int main()
{
    A ex1;    
    A ex2(12,13); // error: use of deleted function 'A::A(int, int)'
    return 0;
}
```

### 什么是类的默认构造函数？
#### Answer
默认构造函数：未提供任何实参，来控制默认初始化过程的构造函数称为默认构造函数。

```cpp
#include <iostream>

using namespace std;

class A
{
public:
    A(){ // 类的默认构造函数
        var = 10;
        c = 'q';
    }
    int var;
    char c;
};

int main()
{
    A ex;
    cout << ex.c << endl << ex.var << endl;
    return 0;
}
/*
运行结果：
q
10
*/
```

### 构造函数、析构函数可不可以是虚函数？为什么？
#### Answer
**构造函数一般不定义为虚函数**，原因：
* 从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。
* 从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。
* 从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。
* 从类型上考虑：在创建对象时需要明确其类型

**析构函数一般定义成虚函数**，原因：
* 析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

### 如何避免拷贝？
#### Answer
方法一：用`=delete`

方法二：将类的拷贝构造函数和赋值构造函数声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。

解决方法：声明一个基类，具体做法如下。
* 定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private
* 派生类以私有 private 的方式继承基类
```cpp
class Uncopyable
{
public:
    Uncopyable() {}
    ~Uncopyable() {}

private:
    Uncopyable(const Uncopyable &);            // 拷贝构造函数
    Uncopyable &operator=(const Uncopyable &); // 赋值构造函数
};
class A : private Uncopyable // 注意继承方式
{ 
};
```
简单解释：
* 能够保证，在派生类 A 的成员函数和友元函数中无法进行拷贝操作，因为无法调用基类 Uncopyable 的拷贝构造函数或赋值构造函数。同样，在类的外部也无法进行拷贝操作。

### 如何减少构造函数开销？
#### Answer
在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销，具体原因可以参考本章“为什么用成员初始化列表会快些？”这个问题。

### 为什么用成员初始化列表会快一些？
#### Answer
**说明：**数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。

**原因：**用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。

```cpp
#include <iostream>
using namespace std;
class A
{
private:
    int val;
public:
    A()
    {
        cout << "A()" << endl;
    }
    A(int tmp)
    {
        val = tmp;
        cout << "A(int " << val << ")" << endl;
    }
};

class Test1
{
private:
    A ex;

public:
    Test1() : ex(1) // 成员列表初始化方式
    {
    }
};

class Test2
{
private:
    A ex;

public:
    Test2() // 函数体中赋值的方式
    {
        ex = A(2);
    }
};
int main()
{
    Test1 ex1;
    cout << endl;
    Test2 ex2;
    return 0;
}
/*
运行结果：
A(int 1)

A()
A(int 2)
*/
```
说明： 从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。


### 多重继承时会出现什么状况？如何解决？
#### Answer
多重继承（多继承）：是指从多个直接基类中产生派生类。
多重继承容易出现的问题：**命名冲突**和**数据冗余**问题。

举例:

```cpp
#include <iostream>
using namespace std;

// 间接基类
class Base1
{
public:
    int var1;
};

// 直接基类
class Base2 : public Base1
{
public:
    int var2;
};

// 直接基类
class Base3 : public Base1
{
public:
    int var3;
};

// 派生类
class Derive : public Base2, public Base3
{
public:
    void set_var1(int tmp) { var1 = tmp; } // error: reference to 'var1' is ambiguous. 命名冲突
    void set_var2(int tmp) { var2 = tmp; }
    void set_var3(int tmp) { var3 = tmp; }
    void set_var4(int tmp) { var4 = tmp; }

private:
    int var4;
};

int main()
{
    Derive d;
    return 0;
}
```

上述程序的继承关系如下：（菱形继承）

![](/images/类相关12.png)

**上述代码中存的问题：**

对于派生类`Derive`上述代码中存在直接继承关系和间接继承关系。

* 直接继承：Base2 、Base3
* 间接继承：Base1

对于派生类中继承的的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了命名冲突。

**解决方法 1： 声明出现冲突的成员变量来源于哪个类**

```cpp
#include <iostream>
using namespace std;

// 间接基类
class Base1
{
public:
    int var1;
};

// 直接基类
class Base2 : public Base1
{
public:
    int var2;
};

// 直接基类
class Base3 : public Base1
{
public:
    int var3;
};

// 派生类 
class Derive : public Base2, public Base3
{
public:
    void set_var1(int tmp) { Base2::var1 = tmp; } // 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3
    void set_var2(int tmp) { var2 = tmp; }
    void set_var3(int tmp) { var3 = tmp; }
    void set_var4(int tmp) { var4 = tmp; }

private:
    int var4;
};

int main()
{
    Derive d;
    return 0;
}
```

**解决方法 2：虚继承**
使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。
实现方式：在继承方式前面加上`virtual`关键字。
```cpp
#include <iostream>
using namespace std;

// 间接基类，即虚基类
class Base1
{
public:
    int var1;
};

// 直接基类 
class Base2 : virtual public Base1 // 虚继承
{
public:
    int var2;
};

// 直接基类 
class Base3 : virtual public Base1 // 虚继承
{
public:
    int var3;
};

// 派生类
class Derive : public Base2, public Base3
{
public:
    void set_var1(int tmp) { var1 = tmp; } 
    void set_var2(int tmp) { var2 = tmp; }
    void set_var3(int tmp) { var3 = tmp; }
    void set_var4(int tmp) { var4 = tmp; }

private:
    int var4;
};

int main()
{
    Derive d;
    return 0;
}
```

类之间的继承关系：
![](/images/类相关13.png)

### 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？
#### Answer
**空类声明时编译器不会生成任何成员函数：**

对于空类，声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。

**空类定义时编译器会生成 6 个成员函数：**

当空类 A 定义对象时，`sizeof(A)`仍是为 1，但编译器会生成 6 个成员函数：**缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符**。

```cpp
#include <iostream>
using namespace std;
/*
class A
{}; 该空类的等价写法如下：
*/
class A
{
public:
    A(){};                                       // 缺省构造函数
    A(const A &tmp){};                           // 拷贝构造函数
    ~A(){};                                      // 析构函数
    A &operator=(const A &tmp){};                // 赋值运算符
    A *operator&() { return this; };             // 取址运算符
    const A *operator&() const { return this; }; // 取址运算符（const 版本）
};

int main()
{
    A *p = new A(); 
    cout << "sizeof(A):" << sizeof(A) << endl; // sizeof(A):1
    delete p;       
    return 0;
}
```

### 为什么拷贝构造函数必须为引用？
#### Answer
原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。

### C++ 类对象的初始化顺序
#### Answer
构造函数调用顺序：

* 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；
* 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数；
* 执行派生类自身的构造函数。

综上可以得出，类对象的初始化顺序：基类构造函数–>派生类成员变量的构造函数–>自身构造函数

注：

* 基类构造函数的调用顺序与派生类的派生列表中的顺序有关；
* 成员变量的初始化顺序与声明顺序有关；
* 析构顺序和构造顺序相反。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
    A() { cout << "A()" << endl; }
    ~A() { cout << "~A()" << endl; }
};

class B
{
public:
    B() { cout << "B()" << endl; }
    ~B() { cout << "~B()" << endl; }
};

class Test : public A, public B // 派生列表
{
public:
    Test() { cout << "Test()" << endl; }
    ~Test() { cout << "~Test()" << endl; }

private:
    B ex1;
    A ex2;
};

int main()
{
    Test ex;
    return 0;
}
/*
运行结果：
A()
B()
B()
A()
Test()
~Test()
~A()
~B()
~B()
~A()
*/
```

程序运行结果分析：

1. 首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；
2. 然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；
3. 最后调用派生类的构造函数；
4. 接下来调用析构函数，和构造函数调用的顺序相反。

### 如何禁止一个类被实例化？
#### Answer
方法一：

* 在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象；

方法二：

* 将类的构造函数声明为私有`private`

### 实例化一个对象需要哪几个阶段？
#### Answer
1. **分配空间** 创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。
2. **初始化** 首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，**初始化列表执行的是数据成员的初始化过程**，这个可以从成员对象的构造函数被调用看的出来。
3. **赋值** 对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）

注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。

* 没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。
* 有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。

### 友元函数的作用及使用场景
#### Answer
作用：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。**通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。**

使用场景：

1. 普通函数定义为友元函数，使普通函数能够访问类的私有成员。

 ```cpp
#include <iostream>

using namespace std;

class A
{
    friend ostream &operator<<(ostream &_cout, const A &tmp); // 声明为类的友元函数

public:
    A(int tmp) : var(tmp)
    {
    }

private:
    int var;
};

ostream &operator<<(ostream &_cout, const A &tmp)
{
    _cout << tmp.var;
    return _cout;
}

int main()
{
    A ex(4);
    cout << ex << endl; // 4
    return 0;
}
```

2. 友元类：类之间共享数据。

 ```cpp
#include <iostream>

using namespace std;

class A
{
    friend class B;

public:
    A() : var(10){}
    A(int tmp) : var(tmp) {}
    void fun()
    {
        cout << "fun():" << var << endl;
    }

private:
    int var;
};

class B
{
public:
    B() {}
    void fun()
    {
        cout << "fun():" << ex.var << endl; // 访问类 A 中的私有成员
    }

private:
    A ex;
};

int main()
{
    B ex;
    ex.fun(); // fun():10
    return 0;
}
```

### 深拷贝和浅拷贝的区别
#### Answer
* 深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。
* 浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容

当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。

浅拷贝实例

```cpp
#include <iostream>

using namespace std;

class Test
{
private:
	int *p;

public:
	Test(int tmp)
	{
		this->p = new int(tmp);
		cout << "Test(int tmp)" << endl;
	}
	~Test()
	{
		if (p != NULL)
		{
			delete p;
		}
		cout << "~Test()" << endl;
	}
};

int main()
{
	Test ex1(10);	
	Test ex2 = ex1; 
	return 0;
}
/*
运行结果：
Test(int tmp)
~Test()
*/
```
说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。

深拷贝实例：

```cpp
#include <iostream>

using namespace std;

class Test
{
private:
	int *p;

public:
	Test(int tmp)
	{
		p = new int(tmp);
		cout << "Test(int tmp)" << endl;
	}
	~Test()
	{
		if (p != NULL)
		{
			delete p;
		}
		cout << "~Test()" << endl;
	}
	Test(const Test &tmp) // 定义拷贝构造函数
	{
		p = new int(*tmp.p);
		cout << "Test(const Test &tmp)" << endl;
	}

};
```

### 编译时多态和运行时多态的区别？
#### Answer
* 编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。
* 运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。

编译时多态和运行时多态的区别：
* 时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；
* 实现方式不同：编译时多态运用**泛型编程**来实现，运行时多态借助**虚函数**来实现。

### 实现一个类成员函数，要求不允许修改类的成员变量？
#### Answer
如果想达到一个类的成员函数不能修改类的成员变量，只需用 const 关键字来修饰该函数即可。

```cpp
#include <iostream>

using namespace std;

class A
{
public:
    int var1, var2;
    A()
    {
        var1 = 10;
        var2 = 20;
    }
    void fun() const // 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰
    {
        var1 = 100; // error: assignment of member 'A::var1' in read-only object
    }
};

int main()
{
    A ex1;
    return 0;
}
```

### 如何让类不能被继承？
#### Answer
解决方法一：借助`final`关键字，用该关键字修饰的类不能被继承。

```cpp
#include <iostream>

using namespace std;

class Base final
{
};

class Derive: public Base{ // error: cannot derive from 'final' base 'Base' in derived type 'Derive'

};

int main()
{
    Derive ex;
    return 0;
}
```

解决方法二：借助友元、虚继承和私有构造函数来实现
```cpp
#include <iostream>
using namespace std;

template <typename T>
class Base{
    friend T;
private:
    Base(){
        cout << "base" << endl;
    }
    ~Base(){}
};

class B:virtual public Base<B>{   //一定注意 必须是虚继承
public:
    B(){
        cout << "B" << endl;
    }
};

class C:public B{
public:
    C(){}     // error: 'Base<T>::Base() [with T = B]' is private within this context
};


int main(){
    B b;  
    return 0;
};
```
说明：在上述代码中 B 类是不能被继承的类。 具体原因：

虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象； B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。 注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。 

### 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？
#### Answer
左值：可以取到地址、有名字的对象。

右值：表达式结束就不再存在的临时对象。

左值和右值的区别：左值持久，右值短暂

右值引用和左值引用的区别：

* 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。
* 右值引用必须绑定到右值的引用，通过 `&&` 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。

`std::move`可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。

```cpp
#include <iostream>
using namespace std;

void fun1(int& tmp) 
{ 
  cout << "fun1(int& tmp):" << tmp << endl; 
} 

void fun2(int&& tmp) 
{ 
  cout << "fun2(int&& tmp)" << tmp << endl; 
} 

int main() 
{ 
  int var = 11; 
  fun1(12); // error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'
  fun1(var);
  fun2(1); 
}
```

### std::move() 函数的实现原理
#### Answer
`std::move()`函数原型：

```cpp
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	return static_cast<typename remove_reference<T>::type &&>(t);
}
```
说明：引用折叠原理

* 右值传递给上述函数的形参 T&& 依然是右值，即 T&& && 相当于 T&&。
* 左值传递给上述函数的形参 T&& 依然是左值，即 T&& & 相当于 T&。

小结：通过引用折叠原理可以知道，`move()`函数的形参既可以是左值也可以是右值。
`remove_reference`具体实现：
```cpp
//原始的，最通用的版本
template <typename T> struct remove_reference{
    typedef T type;  //定义 T 的类型别名为 type
};
 
//部分版本特例化，将用于左值引用和右值引用
template <class T> struct remove_reference<T&> //左值引用
{ typedef T type; }
 
template <class T> struct remove_reference<T&&> //右值引用
{ typedef T type; }   
  
//举例如下,下列定义的a、b、c三个变量都是int类型
int i;
remove_refrence<decltype(42)>::type a;             //使用原版本，
remove_refrence<decltype(i)>::type  b;             //左值引用特例版本
remove_refrence<decltype(std::move(i))>::type  b;  //右值引用特例版本 
```
举例：
```cpp
nt var = 10; 
```
转化过程：
1. `std::move(var)`=>`std::move(int&& &)`=>折叠后`std::move(int&)`
2. 此时：`T`的类型为`int&`，`typename remove_reference<T>::type`为`int`，这里使用`remove_reference`的左值引用的特例化版本
3. 通过`static_cast`将`int&`强制转换为`int&&`

整个std::move被实例化如下
```cpp
string&& move(int& t) 
{
    return static_cast<int&&>(t); 
}
```
总结：`std::move()`实现原理：
* 利用引用折叠原理将右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&& 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；
* 然后通过 remove_refrence 移除引用，得到具体的类型 T；
* 最后通过 static_cast<> 进行强制类型转换，返回 T&& 右值引用。

### 什么是指针？指针的大小及用法？
#### Answer
**指针：**指向另外一种类型的复合类型。
**指针的大小：**在 64 位计算机中，指针占 8 个字节空间。

### 什么是野指针和悬空指针？
#### Answer
**悬空指针：**
若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。 举例：

```cpp
void *p = malloc(size);
free(p); 
// 此时，p 指向的内存空间已释放， p 就是悬空指针。
```

**野指针：**
“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”

```cpp
void *p; 
// 此时 p 是“野指针”。
```

### C++ 11 nullptr 比 NULL 优势
#### Answer
**NULL：**预处理变量，是一个宏，它的值是 0，定义在头文件 中，即`#define NULL 0`。
**nullptr：**C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。

nullptr 的优势：

* 有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。
* 函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。

### 什么是数组指针？什么是指针数组？
#### Answer
* 指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。

* 数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。

### 函数指针和指针函数的区别？
#### Answer
**指针函数：**指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。

```cpp
#include <iostream>
using namespace std;

struct Type
{
  int var1;
  int var2;
};

Type * fun(int tmp1, int tmp2){
    Type * t = new Type();
    t->var1 = tmp1;
    t->var2 = tmp2;
    return t;
}

int main()
{
    Type *p = fun(5, 6);
    return 0;
}
```

**函数指针：**函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。

```cpp
#include <iostream>
using namespace std;
int fun1(int tmp1, int tmp2)
{
  return tmp1 * tmp2;
}
int fun2(int tmp1, int tmp2)
{
  return tmp1 / tmp2;
}

int main()
{
  int (*fun)(int x, int y); 
  fun = fun1;
  cout << fun(15, 5) << endl; 
  fun = fun2;
  cout << fun(15, 5) << endl; 
  return 0;
}
/*
运行结果：
75
3
*/
```

### 指针和引用的区别？
#### Answer
* 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
* 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）
* 指针可以为空，但是引用必须绑定对象。（是否可为空）
* 指针可以有多级，但是引用只能一级。（是否能为多级）

### 常量指针和指针常量的区别
#### Answer
**常量指针：**常量指针本质上是个指针，只不过这个指针指向的对象是常量。 特点：const 的位置在指针声明运算符`*`的左侧。只要`const`位于`*`的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解`*`左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）
```cpp
const int * p;
int const * p;
```
注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。

注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。

**指针常量：**指针常量的本质上是个常量，只不过这个常量的值是一个指针。特点：`const`位于指针声明操作符右侧，表明该对象本身是一个常量，`*`左侧表示该指针指向的类型，即以`*`为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。
```cpp
const int var;
int * const c_p = &var; 
```
注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。

注意 2：指针的内容可以改变。


### 请说出`const char *p`、`char const *p` 与 `char * const p`的区别？
#### Answer
`const char *p`和`char const *p`是**常量指针**，即指向常量的指针，`char * const p`是**指针常量**，即指针本身是常量

#### TIPS
《C++ Primer Plus》一书中提到一种方法，从右往左读，遇到 "p" 就翻译为 "p is a"，遇到 "*" 就翻译为 "point to"。所以`const char *p`可以翻译为"p is a point to char const"，也就是指向常量字符的指针。

### 强制类型转换有哪几种？
#### Answer
* **static_cast：**用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。
    1. 用于基本数据类型的转换。
    2. 用于类层次之间的基类和派生类之间**指针或者引用**的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。
    3. 可以将空指针转化成目标类型的空指针。
    4. 可以将任何类型的表达式转化成 void 类型
* **const_cast：**强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。
* **reinterpret_cast：**改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。
* **dynamic_cast：**
    1. 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。
    2. 只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。
    3. 在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）
```cpp
#include <iostream>
#include <cstring>

using namespace std;

class Base
{
};

class Derive : public Base
{
};

int main()
{
    Base *p1 = new Derive();
    Derive *p2 = new Derive();

    //向上类型转换
    p1 = dynamic_cast<Base *>(p2);
    if (p1 == NULL)
    {
        cout << "NULL" << endl;
    }
    else
    {
        cout << "NOT NULL" << endl; //输出
    }

    return 0;
}
```
    4. 在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。
```cpp
#include <iostream>
#include <cstring>

using namespace std;

class Base
{
public:
    virtual void fun()
    {
        cout << "Base::fun()" << endl;
    }
};

class Derive : public Base
{
public:
    virtual void fun()
    {
        cout << "Derive::fun()" << endl;
    }
};

int main()
{
    Base *p1 = new Derive();
    Base *p2 = new Base();
    Derive *p3 = new Derive();

    //转换成功
    p3 = dynamic_cast<Derive *>(p1);
    if (p3 == NULL)
    {
        cout << "NULL" << endl;
    }
    else
    {
        cout << "NOT NULL" << endl; // 输出
    }

    //转换失败
    p3 = dynamic_cast<Derive *>(p2);
    if (p3 == NULL)
    {
        cout << "NULL" << endl; // 输出
    }
    else
    {
        cout << "NOT NULL" << endl;
    }

    return 0;
}
```

### 参数传递时，值传递、引用传递、指针传递的区别？
#### Answer
参数传递的三种方式：

* 值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。
* 指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。
* 引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。

```cpp
#include <iostream>
using namespace std;

void fun1(int tmp){ // 值传递
    cout << &tmp << endl;
}

void fun2(int * tmp){ // 指针传递
    cout << tmp << endl;
}

void fun3(int &tmp){ // 引用传递
    cout << &tmp << endl;
}

int main()
{
    int var = 5;
    cout << "var 在主函数中的地址：" << &var << endl;

    cout << "var 值传递时的地址：";
    fun1(var);

    cout << "var 指针传递时的地址：";
    fun2(&var);

    cout << "var 引用传递时的地址：";
    fun3(var);
    return 0;
}

/*
运行结果：
var 在主函数中的地址：0x23fe4c
var 值传递时的地址：0x23fe20
var 指针传递时的地址：0x23fe4c
var 引用传递时的地址：0x23fe4c
*/
```
说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。

### 什么是模板？如何实现？
#### Answer
**模板：**创建类或者函数的蓝图或者公式，分为函数模板和类模板。 实现方式：模板定义以关键字 template 开始，后跟一个模板参数列表。
* 模板参数列表不能为空；
* 模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。
```cpp
template <typename T, typename U, ...>
```

**函数模板：**通过定义一个函数模板，可以避免为每一种类型定义一个新函数。
* 对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。
* 函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型
```cpp
#include<iostream>

using namespace std;

template <typename T>
T add_fun(const T & tmp1, const T & tmp2){
    return tmp1 + tmp2;
}

int main(){
    int var1, var2;
    cin >> var1 >> var2;
    cout << add_fun(var1, var2);

    double var3, var4;
    cin >> var3 >> var4;
    cout << add_fun(var3, var4);
    return 0;
}
```

**类模板：**类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。
```cpp
#include <iostream>

using namespace std;

template <typename T>
class Complex
{
public:
    //构造函数
    Complex(T a, T b)
    {
        this->a = a;
        this->b = b;
    }

    //运算符重载
    Complex<T> operator+(Complex &c)
    {
        Complex<T> tmp(this->a + c.a, this->b + c.b);
        cout << tmp.a << " " << tmp.b << endl;
        return tmp;
    }

private:
    T a;
    T b;
};

int main()
{
    Complex<int> a(10, 20);
    Complex<int> b(20, 30);
    Complex<int> c = a + b;

    return 0;
}
```

### 函数模板和类模板的区别？
#### Answer
* 实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。
* 实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。
* 默认参数：类模板在模板参数列表中可以有默认参数。
* 特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。
* 调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。

### 什么是模板特化？为什么特化？
#### Answer
模板特化：模板参数在某种特定类型下的具体实现。分为**函数模板特化**和**类模板特化**
* **函数模板特化：**将函数模板中的全部类型进行特例化，称为函数模板特化。
* **类模板特化：**将类模板中的部分或全部类型进行特例化，称为类模板特化。

**模板特化的原因：**模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。

特化分为**全特化**和**偏特化**：
* **全特化：**模板中的模板参数全部特例化。
* **偏特化：**模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。

说明：要区分下函数重载与函数模板特化 定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。

实例：

```cpp
#include <iostream>
#include <cstring>

using namespace std;
//函数模板
template <class T>
bool compare(T t1, T t2)
{
    cout << "通用版本：";
    return t1 == t2;
}

template <> //函数模板特化
bool compare(char *t1, char *t2)
{
    cout << "特化版本：";
    return strcmp(t1, t2) == 0;
}

int main(int argc, char *argv[])
{
    char arr1[] = "hello";
    char arr2[] = "abc";
    cout << compare(123, 123) << endl;
    cout << compare(arr1, arr2) << endl;

    return 0;
}
/*
运行结果：
通用版本：1
特化版本：0
*/
```

### switch 的 case 里为何不能定义变量
#### Answer
switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的，参考如下实例。

### 迭代器的作用？
#### Answer
作用：在无需知道容器底层原理的情况下，遍历容器中的元素。

### 泛型编程如何实现？
#### Answer
泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。

泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。
* **容器：**涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。
* **迭代器：**在无需知道容器底层原理的情况下，遍历容器中的元素。
* **模板：**可参考本章节中的模板相关问题。

### 说说STL的基本组成部分？
#### Answer
标准模板库STL主要由六大部分组成（前三种最主要）：

1. **容器（Container）**

 一种数据结构，比如list、vector和deques，以**模板类**的形式提供。

2. **算法（Algorithm）**

 用来操作容器中的数据的**模板函数**。
 
3. **迭代器（Iterator）**

 提供了访问容器中对象的方法。
 
4. **仿函数（Function Object）**

 仿函数又称为**函数对象**，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个`operator()`。
 
5. **适配器（Adaptor）**

 简单来说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或者调用现有的函数来实现所需要的功能。主要包括三种适配器 Container Adaptor、Iterator Adaptor、Function Adaptor。
 
6. **空间适配器（Allocator）**

 主要负责：1.对象的创建与销毁；内存的获取与释放。
 
### 容器有哪几种类型？
#### Answer
有**顺序容器、关联式容器、容器适配器**三种，三种类型容器特性分别如下：

1. **顺序容器：**容器并**非排序**的，元素的插入位置同元素的值无关。
 * vector：动态数组。元素在**内存连续**存放，随机**存取**任何元素都能在**常数时间**内完成。在**尾端**增删元素具有较佳的性能
 * deque：双向队列。元素在**内存连续**存放，随机**存取**任何元素都能在**常数时间**内完成（仅次于vector） 。在**两端**增删元素具有较佳的性能（大部分情况下是常数时间）。
 * list：双向链表。元素在**内存不连续**存放。在**任何位置**增删元素都能在**常数时间完成**。**不支持随机存取。**
2. **关联式容器：**元素是**排序**的：插入任何元素，都按相应的排序规则来确定其位置。在查找时具有非常好的性能，通常以**平衡二叉树**的方式实现。
 * set/multiset：集合。**set中不允许相同元素，multiset中允许存在相同元素。**
 * map/multimap：map根据first值对元素从小到大排序。**map中不允许相同first值，multimap中允许存在相同first值。**
3. 容器适配器：**封装了一些基本的容器，使之具备了新的函数功能**，比如把deque封装一下变为一个具有 stack 功能的数据结构。这新得到的数据结构就叫适配器。
 * stack：栈。后进先出。
 * queue：队列。先进先出。
 * priority_queue：优先队列。内部维持某种有序，然后确保优先级最高（通常是最小或最大，对应小顶堆和大顶堆）的元素总是位于头部。最高优先级元素总是第一个出列。

### map的实现原理
#### Answer
**红黑树。**红黑树是非严格平衡的二叉搜索树，具有自动排序的功能，因此map内部所有元素都是有序的。

### hashtable（散列表、哈希表）的实现原理
#### Answer
hashtable采用了**函数映射**的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。

### deque实现原理
#### Answer
**双向队列。**

### list实现原理
#### Answer
**双向链表。**

### STL各个容器查找的时间复杂度是多少？
#### Answer
|容器|原理|插入|查看|删除|
|:---|:---|:---|:---|:---|
|vector|采用一维数组实现，元素在内存连续存放|O(N)|O(1)|O(N)|
|deque|采用双向队列实现，元素在内存连续存放|O(N)|O(1)|O(N)|
|list|采用双向链表实现，元素在内存不连续存放，并且存放在堆中|O(1)|O(N)|O(1)|
| map、set、multimap、multiset|采用红黑树实现，红黑树是平衡二叉树的一种|O(logN)|O(logN)|O(logN)|
|unordered\_map、unordered\_set、unordered\_multimap、unordered\_multiset|采用哈希表实现|O(1)，最坏情况O(N)|O(1)，最坏情况O(N)|O(1)，最坏情况O(N)|

### 说一下STL中迭代器的作用，有指针为何还要迭代器？
#### Answer
迭代器的作用：
 
 1. 用于指向顺序容器和关联容器中的元素 
 2. 通过迭代器可以读取它指向的元素 
 3. 通过非const迭代器还可以修改其指向的元素

迭代器和指针的区别：

* **迭代器不是指针，是类模板，表现的像指针。**他只是模拟了指针的一些功能，重载了指针的一 些操作符，-->、++、--等。迭代器封装了指针，是一个“可遍历STL( Standard Template Library)容器内全部或部分元素”的对象，**本质是封装了原生指针**，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的 ++，--等操作。
* **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

### 迭代器的功能分类？
#### Answer
常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种。

1. **输入迭代器（input iterator）**
 
 * 只读，在每个被遍历的位置上只能读取一次，**只能向前移动**。
 * 支持的操作符有：`*p`、`++p`、`p++`、`p != q` 和 `p == q`
 
2. **输出迭代器（output iterator）**
 
 * 只写，在每个被遍历的位置上只能解析一次，**只能向前移动**。
 * 支持的操作符有：`*p`、`++p`、`p++`、`p != q` 和 `p == q`

3. **正向迭代器（forward iterator）**
 
 * 输入和输出迭代器的结合，可多次读写，但是也**只能向前移动**。
 * 支持的操作符有：`*p`、`++p`、`p++`、`p != q` 和 `p == q`

4. **双向迭代器（bidirectional iterator）**
 
 * 双向迭代器具有正向迭代器的全部功能，并且**能向后移动**。
 * 在正向迭代器的基础上，额外支持`--p` 和 `p--`

5. **随机存取迭代器（random access iterator）**

 * 功能如其名，在双线迭代器的功能上，支持随机访问序列的任意值。**指针就是这样一个迭代器。**
 * 支持以上所有操作

**只有顺序容器和关联容器支持迭代器遍历，**各容器支持的迭代器类别如下表：

|容器|支持迭代器类别|
|:---|:---|
|vector|随机访问|
|deque|随机访问|
|list|双向|
|set|双向|
|multiset|双向|
|map|双向|
|multimap|双向|
|stack|不支持|
|queue|不支持|
|priority\_queue|不支持|


操作系统
---
### 进程和线程有什么区别？
#### Answer
* 进程（Process）是对运行时程序的封装，是**系统进行资源分配和调度的基本单位**；线程（Thread）是进程的子任务，**是CPU调度和分派的基本单位**；
* 线程依赖于进程而存在，一个进程至少有一个线程；
* 进程有自己的独立地址空间，线程共享所属进程的地址空间；
* 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、CPU等；
* 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
* 线程之间的通信更方便，**同一进程下的线程共享全局变量等数据**，而进程之间的通信需要以进程间通信(IPC)的方式进行；
* 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮

### 什么是协程？
#### Answer
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

**协程多与线程进行比较**

* 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程
* 线程进程都是同步机制，而协程则是异步
* 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

### 进程的异常控制流：陷阱、中断、异常和信号
#### Answer
* 陷阱是**有意**造成的“异常”，是执行一条指令的结果。陷阱是**同步**的。陷阱的主要作用是**实现系统调用**。比如，进程可以执行`syscall n`指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，陷入到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行下一条指令。

* 中断由处理器**外部的硬件**产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是**异步**事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。

* 异常是一种**错误情况**，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的错误情况，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为**“故障”**。

* 信号是一种更高层的软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来**通知进程发生了某种系统事件**。

### 同一进程中的线程可以共享哪些数据？
#### Answer
* 进程的代码段

* 进程的公有数据（全局变量、静态变量...）

* 进程打开的文件描述符

 > 文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。

* 进程的当前目录

* 信号处理器/信号处理函数：对收到的信号的处理方式

* 进程ID与进程组ID

### 线程独占哪些资源？
#### Answer
* 线程ID

* 一组寄存器的值

* 线程自身的栈（堆是共享的）

* 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；

* 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）

### 进程间通信有哪些方式？
#### Answer
1. 管道(Pipe)

 > 管道是半双工[^2]的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)

2. 命名管道

 > 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，

3. 消息队列

 > 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
 
 > 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。
 
4. 信号(Signal)

 > 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

 > **Linux系统中常用信号：**
 
 > 1. **SIGHUP：**用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
 > 2. **SIGINT：**程序终止信号。
 > 3. **SIGQUIT：**程序退出信号。
 > 4. **SIGBUS：**进程访问非法地址。
 > 5. **SIGFPE：**运算中出现致命错误，如除零操作、数据溢出等。
 > 6. **SIGKILL：**用户终止进程执行信号。shell下执行kill -9发送该信号。
 > 7. **SIGTERM：**结束进程信号。shell下执行kill 进程pid发送该信号。
 > 8. **SIGALRM：**定时器信号。

5. 共享内存
 
 > 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。

6. 信号量(Semaphore)

 > 初始化操作、P（通过）操作、V（释放）操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态

 > 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 为了获得共享资源，进程需要执行下列操作：（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。（2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。（3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。
7. 套接字(Socket)
> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

### 进程同步问题
#### Answer
> 进程的同步[^3]是目的，进程间通信是实现进程同步的手段

管程 Monitor

管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。

当一个进程试图进入管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在紧急等待队列中等待。（HOARE管程）

* wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；
* signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（HOARE管程）

MESA管程：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换

### 线程同步有哪些方式？
#### Answer
为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。

* 互斥量 Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；
* 信号量 Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1。**如果信号量的取值只能为0或1，那么信号量就成为了互斥量；**
* 事件 Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。
* 临界区 Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。

### 互斥量和临界区有什么区别？
#### Answer
互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。

### 生产者-消费者问题
#### Answer
> 问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据

代码实现（C++版）：

1. 单生产者-单消费者

 ```cpp
#include <unistd.h>

#include <condition_variable>
#include <iostream>
#include <thread>
#include <queue>


struct resource {
    std::queue<int> buf;  // 缓冲区
    const int bufCapacity = 10;
    const int productsNum = 20;
    int bufSize = 0;  // 现在缓存区里有多少产品
    std::mutex mtx;  // 互斥量，同一时间只能读或写
    std::condition_variable able_to_write;  // 缓存区没满时，可以写
    std::condition_variable able_to_read;  // 缓存区不为空时，可以读
} res; // 产品库全局变量, 生产者和消费者操作该变量.

void produce(int item) {
    std::unique_lock<std::mutex> lock(res.mtx);
    while (res.bufSize >= res.bufCapacity) {
        std::cout << "缓存区已满，等待消费..." << std::endl;
        res.able_to_write.wait(lock);  // 等待缓存区空位
    }
    std::cout << "正在生产产品 " << item << std::endl;
    res.buf.emplace(item);
    ++res.bufSize;
    res.able_to_read.notify_all();
}

void consume() {
    std::unique_lock<std::mutex> lock(res.mtx);
    while (res.bufSize <= 0) {
        std::cout << "缓存区为空，等待生产..." << std::endl;
        res.able_to_read.wait(lock);  // 等待缓存区空位
    }

    int item = res.buf.front();
    std::cout << "正在消费产品 " << item << std::endl;
    res.buf.pop();
    --res.bufSize;
    res.able_to_write.notify_all();
}


void Producer() {  // 生产者
    for (int i = 1; i <= res.productsNum; ++i) {
        produce(i);
    }
}

void Consumer() {  // 消费者
    for (int i = 1; i <= res.productsNum; ++i) {
        sleep(1);
        consume();
    }
}

int main() {
    std::thread producer(Producer); // 创建生产者线程.
    std::thread consumer(Consumer); // 创建消费之线程.
    producer.join();
    consumer.join();
}
```

### 什么叫临界资源和临界区？
#### Answer
* 临界资源是指每次仅允许一个进程访问的资源。

* 每个进程中访问临界资源的那段代码称为临界区。

### 同步与互斥的概念？
#### Answer
* 同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；

* 互斥：多个进程在同一时刻只有一个进程能进入临界区

### 并发、并行、异步的区别？
#### Answer
* **并发**：在一个时间段中同时有多个程序在运行，但其实**任一时刻，只有一个程序在CPU上运行**，宏观上的并发是通过不断的切换实现的。

* **多线程**：并发运行的一段代码。是实现异步的手段。

* **并行**（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是**同时**执行的。

* **异步**（和同步相比）：同步是顺序执行，异步是在**等待某个资源的时候继续做自己的事**。

### 进程有哪几种状态？
#### Answer
![](/images/进程状态.png)
* 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
* 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
* 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

### 进程调度策略有哪些？
#### Answer
1. 批处理系统：
    * **先来先服务 first-come first-serverd（FCFS）**
        * 按照请求的顺序进行调度。
        * 非抢占式，开销小，无饥饿问题[^4]，响应时间不确定（可能很慢）；
        * 对短进程不利，对IO密集型进程不利。
    * **最短作业优先 shortest job first（SJF）**
        * 按估计运行时间最短的顺序进行调度。
        * 非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；
        * 对短进程提供好的响应时间，对长进程不利。
    * **最短剩余时间优先 shortest remaining time next（SRTN）**
        * 按剩余运行时间的顺序进行调度。
        * (最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；
        * 可能导致饥饿问题，对长进程不利。
    * **最高响应比优先 Highest Response Ratio Next（HRRN）**
        * 按照队列中响应比的顺序进行调度。
        * 响应比=（等待时间+要求服务时间）/要求服务时间。
        * 既考虑作业的执行时间也考虑作业的等待时间，综合了先来先服务和最短作业优先两种算法的特点。
2. 交互式系统：

 > 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

    * **时间片轮转 Round Robin**
        * 将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。
        * 抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；
        * 若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证
    * **优先级调度算法**
        * 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
    * **多级反馈队列调度算法** Multilevel Feedback Queue
        * 设置多个就绪队列1、2、3...，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。
        * 抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。

### 什么叫优先级反转？如何解决？
#### Answer
高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。

解决方法：

* 优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。
* 优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。

### 什么是僵尸进程？
#### Answer
一个子进程结束后，他的父进程没有通过`wait()`系统调用回收他的进程描述符的信息，该进程会继续停留在系统的进程表中，占用内核资源，那么这个子进程将成为一个僵尸进程。**僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。**它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。

**危害：占用进程号，而系统所能使用的进程号是有限的。**

以下情况不会产生僵尸进程：

* 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。
* 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入WNOHANG(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；
* 子进程结束时，系统会产生SIGCHLD(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；
* 也可以用signal(SIGCLD, SIG_IGN)(signal-ignore)通知内核，表示忽略SIGCHLD信号，那么子进程结束后，内核会进行回收。

### 什么是孤儿进程？
#### Answer
一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。

### 什么是用户态和内核态？
#### Answer
为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。

* 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；
* 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。

所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU>切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

### 为什么要分用户态和内核态？
#### Answer
* 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；
* 封装性：用户程序不需要实现更加底层的代码；
* 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。

### 如何从用户态切换到内核态？
#### Answer
* 系统调用：比如读取命令行输入。本质上还是通过中断实现
* 用户程序发生异常时：比如缺页异常
* 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序

### 什么是IO多路复用？怎么实现？
#### Answer
IO多路复用（IO Multiplexing）是指**单个进程/线程**就可以同时处理多个IO请求。

实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

> 操作系统为每一个进程维护了一个文件描述符表，该表的索引值都从从0开始的

|  |select|poll|epoll|
|:---:|:---:|:---:|:---:|
|操作方式|遍历|遍历|回调|
|底层实现|数组|链表|红黑树|
|IO效率|每次调用都进行线性遍历，时间复杂度为O(n)|每次调用都进行线性遍历，时间复杂度为O(n)|事件通知方式，每当fd就绪，系统注册的回调[^5]函数就会被调用，将就绪fd放到readyList里面，时间复杂度为O(1)|
|最大连接数|1024(x86)或2048(x64)|无上限|无上限|
|fd拷贝|每次调用select，都需要把fd集合从用户态拷贝到内核态|每次调用poll，都需要把fd集合从用户态拷贝到内核态|调用epoll\_ctl时拷贝进内核并保存，之后每次epoll\_wait不拷贝|

### select/poll/epoll三者的区别？
#### Answer
* select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点2）集合大小有限制，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降；
* poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
* epoll：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

总结，区别主要在于：

* 一个线程/进程所能打开的最大连接数
* 文件描述符传递方式（是否复制）
* 水平触发 or 边缘触发

 > **水平触发:**就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要有数据可读(描述符就绪)那么水平触发的epoll就立即返回.
 
 > **边缘触发:**只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据可读,但是io状态没有变化epoll也不会立即返回.
* 查询就绪的描述符时的效率（是否轮询）

### 什么时候使用select/poll，什么时候使用epoll？
#### Answer
当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多； 但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。

### 什么是文件描述符？
#### Answer
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 内核通过文件描述符来访问文件。文件描述符指向一个文件。

### 什么是水平触发？什么是边缘触发？
#### Answer
* 水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；
* 边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。
**区别：**边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。

### 有哪些常见的IO模型？
#### Answer
* 同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；
* 同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；
* IO多路复用
* 异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。

### 为什么边缘触发一定要用非阻塞（non-block）IO?
#### Answer
使用边缘触发，读数据的时候必须读完。剩余在 buffer 里的数据并不会使得 epoll\_wait 返回。如果不读完就去 wait ，可能之后没有新事件过来，那么 epoll\_wait 一直不返回，剩在 buffer 里的数据就读不到了。而读完所有数据可能需要很长时间，在这段时间里没有机会去 wait ，也没有机会处理 epoll 里可能发生的其它事件

使用非阻塞 fd ，read 不会阻塞，read 过程中可以继续去查看 epoll 中的事件。

使用水平触发，可以一次读一点，然后去 epoll\_wait 。只有缓存还有数据，epoll\_wait 就会立即返回，不会阻塞。这样可以保证 epoll 里所有 fd 的事件都有处理机会。


[^2]:半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。
[^3]:同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才会继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。 当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。
[^4]:进程出现饥饿现象是指进程的优先级较低而长时间得不到调度。
[^5]:在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过参数将函数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。

### 操作系统有几种内存管理方式？
#### Answer
* 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
* 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
* 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

区别：
* 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
* 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
* 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
* 分段便于信息的保护和共享；分页的共享收到限制；
* 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

### 什么是内碎片和外碎片？
#### Answer
“碎片的内存”描述一个系统中所有不可用的空闲内存。这些资源之所以仍然未被使用，是因为负责分配内存的分配器使这些内存无法使用。这一问题通常都会发生，原因在于空闲内存以小而不连续方式出现在不同的位置。

在内存管理中，**内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间**。

**外部碎片是指还没有分配出去，但是由于太小而无法分配给申请空间的新进程的内存空间空闲块**。

### 什么是虚拟内存？
#### Answer
每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。

**虚拟内存的优点是让程序可以获得更多的可用内存。**

### 如何进行地址空间到物理内存的映射？
#### Answer
**内存管理单元**（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。

### 有哪些页面置换算法？
#### Answer
在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。
* **最佳页面置换算法OPT**（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；
* **先进先出FIFO**：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
* **第二次机会算法SCR**：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
* **时钟算法 Clock**：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
* **最近未使用算法NRU**（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
* **最近最少使用算法LRU**（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
* **最不经常使用算法NFU**：置换出访问次数最少的页面

### 什么是局部性原理？
#### Answer
* 时间上：最近被访问的页在不久的将来还会被访问；
* 空间上：内存中被访问的页周围的页也很可能被访问。

### 什么是颠簸现象？
#### Answer
颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：

* 修改页面置换算法；
* 降低同时运行的程序的数量；
* 终止该进程或增加物理内存容量。

### 什么是缓冲区溢出？
#### Answer
C 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C 对于数组引用不进行任何边界检查，因此**对越界的数组元素的写操作会破坏存储在栈中的状态信息**，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。

### 怎么防治缓冲区溢出？
#### Answer
防范缓冲区溢出攻击的机制有三种：**随机化**、**栈保护**和**限制可执行代码区域**。

* 随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。
* 栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。
* 限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。

### 什么是磁盘调度？
#### Answer
磁盘调度算法是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做的。其中寻道是磁盘较为耗时的部分，因此如果请求顺序得当，可以节省一些不必要的寻道时间。

寻道算法有：

* 先来先服务
* 最短寻道时间优先
* 电梯算法（扫描算法）：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。
* LOOK与C-LOOK算法：LOOK算法和C-LOOK算法分别是对扫描算法和循环扫描算法的优化，优化的思路就是：**磁头移动到最远的请求位置，然后立刻向反方向移动。**
 * LOOK算法反向移动途中会响应请求
 * C-LOOK反向移动途中不响应请求

### 什么是死锁？
#### Answer
在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。

### 死锁产生的必要条件？
#### Answer
* 互斥：一个资源一次只能被一个进程使用；
* 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
* 非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
* 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。

### 死锁有哪些处理方法？
#### Answer
**鸵鸟策略**

直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

**死锁预防**

基本思想是破坏形成死锁的四个必要条件：

* 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；
* 破坏占有并等待条件：
    * 实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；
    * 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；
    * 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；
* 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；
* 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。

**死锁避免**

动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。

> [银行家算法](https://www.cnblogs.com/wkfvawl/p/11929508.html)：银行家算法的实质就是要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。
> 
> 银行家算法的执行有个前提条件，即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量。

**死锁解除**

> 如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。

死锁解除的方法：

* 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；
* 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；
* 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。


计算机网络
---
### 简述计算机网络体系结构
#### Answer
计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层），五层体系结构。

* OSI体系结构: 概念清楚，理论也比较完整，但是它既复杂又不实用。
* TCP/IP体系结构:TCP/IP是一个四层体系结构，得到了广泛的运用。
* 五层体系结构:为了方便学习，折中OSI体系结构和TCP/IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。

![](/images/计网体系结构.png)

TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际运行的网络协议。

### 说一下五层体系结构每一层的主要功能
#### Answer
* 应用层：应用层是网络协议的最高层，主要任务通过进程间的交互完成特定网络应用。应用层协议定义的是应用程序（进程）间通信和交互的规则。应用层交互的数据单元称为报文。对于不同的网络应用需要有不同的应用层协议，在互联网中的应用层协议很多:
  * FTP(21端口)：文件传输协议
  * SSH(22端口)：远程登录 更安全
  * TELNET(23端口)：远程登录 更高效
  * SMTP(25端口)：发送邮件
  * POP3(110端口)：接收邮件
  * HTTP(80端口)：超文本传输协议
  * DNS(53端口)：运行在UDP上，域名解析服务
* 运输层：有时也译为传输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：
  * 传输控制协议 (Transmission Control Protocol，**TCP**)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；
  * 用户数据报协议 (User Datagram Protocol，**UDP**)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。
* 网络层：网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送。
  * 在TCP/IP体系中，由于网络层使用**IP**协议，因此分组也叫IP数据报。
* 数据链路层：数据链路层通常简称为链路层。数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。
* 物理层：保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。

### IP地址怎么分类？
#### Answer
![](/images/IP地址分类.png)

路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。

### 什么叫划分子网？什么是子网掩码？
#### Answer
从主机号host-id借用若干个比特作为**子网号**subnet-id；**子网掩码**：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。

划分子网时，随着子网地址借用主机位数的增多，子网的数目随之增加，而每个子网中的可用主机数逐渐减少。以C类网络为例，原有8位主机位，2的8次方即256个主机地址，默认子网掩码255.255.255.0。借用1位主机位，产生2个子网，每个子网有126个主机地址；借用2位主机位（子网号），产生4个子网，每个子网有62个主机地址……

每个子网中，第一个IP地址（即主机部分全部为0的IP）和最后一个IP（即主机部分全部为1的IP）不能分配给主机使用，所以每个子网的可用IP地址数为总IP地址数量减2；根据子网ID借用的主机位数，我们可以计算出划分的子网数、掩码、每个子网主机数，列表如下：

|划分子网数|子网位数|子网掩码（二进制）| 子网掩码（十进制）|每个子网主机数|
|:----:|:----:|:----:|:----:|:----:|
|1～2 |1|11111111.11111111.11111111.10000000|255.255.255.128|126|
|3～4|2|11111111.11111111.11111111.11000000|255.255.255.192|62|
|5～8|3|11111111.11111111.11111111.11100000|255.255.255.224|30|
|9～16|4|11111111.11111111.11111111.11110000|255.255.255.240|14|
|17～32|5|11111111.11111111.11111111.11111000|255.255.255.248|6|
|33～64|6|11111111.11111111.11111111.11111100|255.255.255.252|2|

如上表所示的C类网络中，若子网占用7位主机位时，主机位只剩一位，无论设为0还是1，都意味着主机位是全0或全1。由于主机位全0表示本网络，全1留作广播地址，这时子网实际没有可用主机地址，所以主机位至少应保留2位。

### 什么是ARP协议 (Address Resolution Protocol)？
#### Answer
**ARP协议完成了IP地址与物理地址的映射。**每一个主机都设有一个 ARP 高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的 ARP 高速缓存中有没有目的主机的 MAC 地址，如果有，就直接将数据包发到这个 MAC 地址，如果没有，就向所在的局域网发起一个 ARP 请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的 IP 地址和目的主机的 IP 地址是否一致，如果一致，则先保存源主机的映射到自己的 ARP 缓存，然后给源主机发送一个 ARP 响应数据包。源主机收到响应数据包之后，先添加目的主机的 IP 地址与 MAC 地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示 ARP 查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。

### 什么是NAT (Network Address Translation, 网络地址转换)？
#### Answer
用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

### 什么是三次握手？
#### Answer
![](/images/三次握手.png)
* 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，**进入SYN_SENT状态；**
* 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=seq+1，并随机产生一个自己的初始序列号，发送给Client，**进入SYN_RCVD状态；**
* 第三次握手：Client检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=Server序列号+1，发送给Server，**进入ESRABLISHED状态；**Server检查ACK为1和acknowledge number为序列号+1之后，**也进入ESTABLISHED；**完成三次握手，连接建立。

### TCP建立连接可以两次握手吗？为什么？
#### Answer
不可以。原因有二：
首先，可能会出现**已失效的连接请求报文段又传到了Server。**
> client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。

其次，两次握手无法保证Client正确接收第二次握手的报文，即Server无法确认Client是否收到，也无法保证Client和Server之间成功互换初始序列号。

### 可以采用四次握手吗？为什么？
#### Answer
可以。但是会降低传输的效率。
四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。

### 第三次握手中，如果客户端的ACK未送达服务器，会怎样？
#### Answer
+ server端：由于server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。
+ client端，有两种情况：
    1. 在Server进行超时重发的过程中，如果Client向Server发送数据，数据头部的ACK为1，则Server收到数据之后会读取acknowledge number，进入ESTABLISHED状态；
    2. 在Server进入CLOSED状态之后，如果Client向Server发送数据，Server会以RST包应答。

### 如果已经建立了连接，但Client端出现了故障怎么办？
#### Answer
Server每收到一次Client的请求后都会重新复位一个计时器，时间通常设置为两个小时，如果两小时内还没收到Client的任何数据，Server就会发送一个探测报文段，之后每隔75秒发送一次。若连续10个探测报文都没有回应，Server就会认为Client端出了故障，接着就关闭连接。

### 初始序列是什么？
#### Answer
TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。

### 什么是四次挥手？
#### Answer
![](/images/四次挥手.png)
* 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；**进入FIN_WAIT_1状态；**
* 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；**进入CLOSE_WAIT状态；**此时Client已经没有要发送的数据了，但仍可以接受Server发来的数据。
* 第三次挥手：Server将FIN置1，发送一个序列号给Client；**进入LAST_ACK状态；**
* 第四次挥手：Client收到服务器的FIN后，**进入TIME_WAIT状态；**接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number，**变为CLOSED状态，**不再向客户端发送数据。客户端等待2\*MSL[^6]（报文最长寿命）事件后，**也进入CLOSED状态。**完成四次挥手。

### 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？
#### Answer
因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

### 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？
#### Answer
客户端没有收到ACK确认，会重新发送FIN请求。

### 客户端TIME_WAIT状态的意义是什么？
#### Answer
第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

[^6]: MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。

### TCP如何实现流量控制？
#### Answer
![](/images/TCP窗口字段1.png)
使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。
![](/images/TCP窗口字段2.png)
发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。

### 什么是零窗口（接收窗口为0时会怎样）？
#### Answer
如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### TCP的拥塞控制是怎么实现的？
#### Answer
![](/images/TCP拥塞控制1.png)
拥塞控制主要由四个算法组成：**慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）**
1. 慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍
![](/images/TCP慢启动.png)
2. 拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.
    > 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。（这是不使用快重传的情况）
3. 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出**重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
![](TCP快重传.png)
4. 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。
![](TCP快恢复.png)

### TCP如何最大利用带宽？
#### Answer
TCP速率受到三个因素影响
* 窗口：即滑动窗口大小，见**TCP如何实现流量控制？**
* 带宽：这里带宽是指单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制。TCP发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。
* RTT：即Round Trip Time，表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会对RTT进行采样（即对发送的数据包及其ACK的时间差进行测量，并根据测量值更新RTT值），TCP根据得到的RTT值更新RTO值，即Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则认为数据包丢失，将重传数据。一般RTO值都比采样得到的RTT值要大。

### 带宽时延乘积怎么算？
#### Answer
设滑动窗口大小为$W$， 发送端和接收端的带宽为$B$， RTT为$T_r$。

前面已经说过了，TCP发送数据时受滑动窗口的限制，当TCP将滑动窗口中的数据都发出后，在收到第一个ACK之前，滑动窗口大小是0，不能再发送数据了，必须等待ACK包使滑动窗口移动。那么在理想情况下，ACK包应该在什么时候到达呢？显然，就是在数据发出后的RTT时间后，ACK包到达。这也就是说，现在在不考虑丢包和拥塞情况下，TCP在一个RTT时间内能发出的最大数据量为$W$，所以不考虑带宽限制下，TCP能一个时刻能达到的最大速度是$V=\frac{W}{T_r}$。

现在再考虑带宽限制，前面说过当马路上摆满车的时候，就无法再往里放车了，同理，TCP发送端在$\frac{T_r}{2}$时间内，能往通道上放的最大数据量为$\frac{V \ast T_r}{2}$，通过带宽时延乘积得到的容积限制为$\frac{B \ast T_r}{2}$。当$\frac{B \ast T_r}{2}\geq\frac{V \ast T_r}{2}$时，单向通道容积不构成瓶颈，速率的限制主要来源于窗口大小限制。而当$\frac{B\ast T_r}{2}\leq\frac{V\ast T_r}{2}$时，则就受到容积限制，即此时速率限制来源于带宽限制。

因此，TCP的最大速率为$V=min(\frac{W}{T_r}, B)$。

在我们平时生活中使用的宽带网络，ADSL（非对称数字用户线路）等环境下，因为带宽都比较小，从而$B\ast T_r$也比较小，再加上网络情况比较复杂，拥塞情况比较常见，所以这些网络环境下，TCP速率的主要限制因素在于带宽，丢包率等。在这些网络中速率的主要限制因素就是窗口大小了，这也是传统TCP在这些网络环境中不能充分利用带宽的原因所在（因为传统TCP的窗口大小是用2字节表示的，所以最大只有65535（不考虑窗口扩大选项）），除了专线网络外，随着网络硬件技术的发展，万兆交换机的出现，局域网中也可能会出现带宽时延乘积较大的情况。

### TCP与UDP的区别
#### Answer
1. TCP是面向连接的，UDP是无连接的；
> 什么叫无连接？UDP发送数据之前不需要建立连接
2. TCP是可靠的，UDP不可靠；
> 什么叫不可靠？UDP接收方收到报文后，不需要给出任何确认
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；
> 什么意思？面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
5. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；
6. TCP首部开销（20字节）比UDP首部开销（8字节）要大
7. UDP 的主机不需要维持复杂的连接状态表

### UDP报文结构和TCP报文结构？
#### Answer
UDP头结构
![](/images/UDP头结构.png)

1. 源端口号，目的端口号：发送端和接收端的端口号
2. 长度：UDP用户数据报的长度，最小值是8字节（只有首部）
3. 校验和：检测UDP用户数据报在传输中是否出错，出错就丢弃
TCP头结构
![](/images/TCP头结构.png)
4. 源端口号，目的端口号：发送端和接收方的窗口号
5. 序列号：本报文段的数据第一个字节的序号
6. 确认号：期望收到的对方下一个报文段的第一个数据字节的序号
7. 首部长度：TCP报文段的数据起始处距离TCP报文段的起始处有多长，以4字节为计算单位
8. 保留：保留为今后使用，目前置为0
9. 紧急URG：此位置1，表明紧急指针字段有效，告诉系统此报文段有紧急数据，应尽快传送
10. 确认ACK：=1时确认号字段有效，在连接建立后所有传达的报文段都必须把 ACK 置1
11. 推送PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够12. 收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付
13. 复位RST：用于复位相应的TCP连接
14. 同步SYN：仅在三次握手建立TCP连接时有效。
 > SYN=1，ACK=0时，表明这是一个连接请求报文段，若对方同意建立连接，则应在相应的报文段中使用SYN=1和ACK=1
15. 终止FIN：用来释放一个连接，当FIN=1时，表明此报文段发送方的数据已经发送完毕，并要求释放连接
16. 窗口：指发送本报文段的一方的接受窗口（不是自己的发送窗口）
17. 校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头部
18. 紧急指针：仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据
19. 选项：长度可变，最多40字节


### 什么时候选择TCP，什么时候选UDP？
#### Answer
对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失

### HTTP可以使用UDP吗？
#### Answer
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠
注：**http 3.0 使用udp实现** [HTTP3维基百科](https://zh.wikipedia.org/wiki/HTTP/3)

### 面向连接和无连接的区别
#### Answer
无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）
数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；
虚电路（Virtual Circuit，VC）服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；
![](/images/虚电路数据包服务区别.png)

### TCP如何保证传输的可靠性？
#### Answer
1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 丢弃重复数据
4. 应答机制：接收方收到数据之后，会发送一个确认；
5. 超时重传：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

### UDP怎么实现可靠传输？
#### Answer
在应用层实现发送/接收队列、确认机制、超时重传、流量控制（滑动窗口）、拥塞控制（拥塞窗口）等……

### HTTP请求/响应格式是什么样的？
#### Answer
HTTP协议客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据；

![](/images/http结构.png)

服务端响应response也由四个部分组成，分别是：响应行、响应头、空行、响应体。

请求头部字段包括：

* Accept：能够接受的回应内容类型
* Accept-Charset：能够接受的字符集
* Accept-Encoding：能够接受的编码方式列表
* Connection：该浏览器想要优先使用的连接类型
* Date：发送该消息的日期和时间(按照 RFC 7231 中定义的"超文本传输协议日期"格式来发送)
* Host：服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略
* ……

响应头部字段包括：

* Age：这个对象在代理缓存中存在的时间，以秒为单位
* Access-Control-Allow-Origin：指定哪些网站可参与到跨来源资源共享过程中
* Accept-Patch：指定服务器支持的文件格式类型。
* Date
* Allow：对于特定资源有效的动作。针对HTTP/405这一错误代码而使用
* Connection
* ……

### HTTP有哪些请求方法？
#### Answer
HTTP协议定义了多种请求方式，具体如下：
GET：**获取资源**，用来请求访问已被URI（统一资源标志符，和URL是包含和被包含的关系，URL是最常见的URI）识别的资源。
POST：用来**传输实体的主体**，虽然GET也可以实现，但是一般不用。
PUT：**传输文件**。但是鉴于PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般网站都不采用该方法。
HEAD：**获得报文首部**。和GET请求一样，只是不返回报文主体部分。
DELETE：**删除文件**。同样不带验证机制，存在安全性问题。
OPTIONS：**询问指定的请求URI支持哪些方法**。
TRACE：**追踪路径**，让Web服务器将之前的请求通信环回给客户端的方法。
CONNECT：要求在**与代理服务器通信时建立隧道**，实现隧道协议进行TCP通信。

### GET与POST有什么区别？
#### Answer
1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；
 > 幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同
2. GET一般用于从服务器获取资源，而POST可以改变服务器上的资源；
3. 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；
4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；
6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制

### Get和Head有什么区别？
#### Answer
HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，用HEAD意义更加明确。

### HTTP和HTTPS有什么区别？
#### Answer
1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
3. HTTPS由于加密解密会带来更大的CPU和内存开销；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

### Https的连接过程（即SSL建立连接过程）？
#### Answer
![](/images/https建立过程.png)
1. 客户端向服务器发送请求，同时附带支持的加密规则（包括对称加密、非对称加密、摘要算法）；
2. 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；
3. 客户端验证服务器的合法性，包括：证书是否过期，CA（证书颁发机构） 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；
4. 如果证书受信任，或者用户接受了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；
5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。
总结：**非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。**

### 浏览器怎么验证SSL证书？
#### Answer
由于证书是分等级的，网站拥有者可能从根证书颁发机构领到证书，也可能从根证书的下一级(如某个国家的认证中心，或者是某个省发出的证书)领到证书。假设我们正在访问某个使用了SSL证书的网站，IE浏览器就会收到了一个SSL证书，如果这个证书是由根证书颁发机构签发的，IE浏览器就会按照下面的步骤来检查:浏览器使用内置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信任的颁证机构签发的，这个网站就是安全可靠的；如果该SSL证书不是根服务器签发的，浏览器就会自动检查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证书也是可信的。

浏览器验证SSL证书5个方面：

第一，检查SSL证书是否是由浏览器中“受信任的根证书颁发机构”颁发。

检查到如果网站部署的SSL证书不是浏览器受信任的根证书颁发机构，则会有安全警告，为IE7浏览器的警告信息为“此网站出具的安全证书不是受信任的证书颁发机构颁发的，安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据，建议关闭此网页，并且不要继续浏览该网站。”IE6浏览器会提示“该安全证书由您没有选定信任的公司颁发”。一般自签名SSL证书和其它不是全球浏览器信任的证书多会出现此种情况。

第二，检查SSL证书中的证书吊销列表，检查证书是否被证书颁发机构吊销。

检查SSL证书中的证书吊销列表，如果已经被吊销，则会显示警告信息：“此组织的证书已被吊销。安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据。建议关闭此网页，并且不要继续浏览该网站。”

第三，检查此SSL证书是否过期。

检查网站SSL证书的有效期限，如果证书已经过了有效期，则会显示警告信息：“此网站出具的安全证书已过期或还未生效。安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据。建议关闭此网页，并且不要继续浏览该网站。”

第四，检查部署此SSL证书的网站的域名是否与证书中的域名一致。

检查部署此SSL证书的网站的域名是否与证书中的域名一致，如果不一致，则浏览器也会显示警告信息：“此网站出具的安全证书是为其他网站地址颁发的。安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据。建议关闭此网页，并且不要继续浏览该网站。”

第五，到欺诈网站数据库查询此网站是否已经被列入欺诈网站黑名单。

如果发现此网站已经被列入欺诈网站黑名单，则会显示：“IE已发现一个已报告的仿冒网站。仿冒网站假冒其他网站并试图欺骗您泄漏个人信息或财务信息。建议关闭此网页，并且不要继续浏览该网站。”

浏览器需经过以上5个方面的检查后，才会在页面显示安全锁标志，正常显示部署了SSL证书的加密页面。

### HTTP 怎么切换到 HTTPS ？
#### Answer
一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。
 > 302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect）

第二种是引入HSTS （HTTP 严格传输安全，HTTP Strict Transport Security）机制，用户浏览器在访问站点的时候强制使用HTTPS。


### HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？
#### Answer
**使用双向认证。**

攻击者在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误。

HTTPS因为增加了CA证书，可以在会话前通过证书验证证明通信的彼此就是所声称的人，因此可以防范中间人攻击。这种防范中间人攻击的前提是在HTTPs协议的双向认证上。如果仅仅实现了HTTPs的单向认证，如不验证客户端，只验证服务器，这种情况下还是不能抵御中间人攻击的，这种情况下就会出现**SSL剥离攻击（SSLTrip）**和**SSL劫持攻击**。

SSL剥离攻击剥离SSL协议，表现为用户和攻击者之间使用HTTP，攻击者和服务器之间使用https协议。
> 如何防止SSL剥离攻击？可以（1）在服务器上开启HSTS，使服务器只接收使用HTTPS的连接。（2）将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。

SSL劫持攻击表现为用户和攻击者之间使用攻击者伪造的CA证书使用其https协议进行通信，（其中重要的步骤是把burpsuit的CA根证书导入用户浏览器，这样用户浏览器就能信任假CA发给中间人的证书(即信任中间人burpsuit)，建立客户端和中间人之间的会话信道）。而攻击者和服务器之间使用真正的CA证书创建的对称秘钥进行加密，攻击者收到客户端信息先用前者会话秘钥解密，再使用后者之间的会话秘钥加密。这样使得客户端和服务器都以为是和真正的对方通信。
> 如何防止SSL劫持攻击？使用https双向认证

### 什么是对称加密、非对称加密？区别是什么？
#### Answer
* 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
* 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA
区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）

### 数字签名、报文摘要的原理？
#### Answer
* 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。
* 摘要算法:MD5、SHA
> **MD5信息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致

### Session与Cookie的区别？
#### Answer
Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案

Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。

> 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。URL重写的技术来进行会话跟踪，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。Session是在服务端保存的一个数据结构，用来跟踪用户的状态；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

### 从输入网址到展示页面的过程 (包括DNS如何解析成IP)？
#### Answer
1. **输入网址**

 > 当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。
 
2. **浏览器查找域名的 IP 地址**

 > 1. 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。
 
 > 2. 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。

 > 3. 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是**递归**的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。

 > 4. 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是**迭代**的过程。

 > 5. 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。

 > 6. 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。
 
3. **浏览器向web服务器发送一个HTTP请求**
 
 > 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。
 
 > 建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 **GET** 或者 **POST** 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。
 
 > 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：
 
 > * 请求行
 > * 请求头(Request Header)
 > * 空行（发送回车符和换行符，通知服务器以下不再有请求头）
 > * 请求正文
 
 > 下面是一个完整的HTTP请求例子：
 
 > ```cpp
 GET/sample.jspHTTP/1.1
Accept:image/gif.image/jpeg,*/*
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=wangtianyang&password=1234
 > ```

4. **服务器的永久重定向响应**

 > 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问 http://www.google.com/ 而非 http://google.com/ 。

 > 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 http://www.google.com/ 和 http://google.com/ ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。

5. **浏览器跟踪重定向地址**

 > 现在浏览器知道了 http://www.google.com/ 才是要访问的正确地址，所以它会发送另一个http请求。

6. **服务器处理请求**
 
 > 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？

 > 后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。

 > 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。

 > 此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。
 
 > 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。
 
 > 如图所示：
 
 > ![](/images/服务器处理请求.jpeg)
 
7. **服务器返回一个 HTTP 响应**

 > 经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTTP响应。

 > HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：

 > * 状态行
 > * 响应头(Response Header)
 > * 空行
 > * 响应正文
 
 > ```cpp
HTTP/1.1 200 OK
Date: Sat, 31 Dec 2005 23:59:59 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122

＜html＞
＜head＞
＜title＞http＜/title＞
＜/head＞
＜body＞
＜!-- body goes here --＞
＜/body＞
＜/html＞
 > ```
 
8. **浏览器解析、渲染、展示页面**

### 什么是DNS？
#### Answer
DNS（Domain Name System，域名系统）是因特网上作为域名和IP地址相互映射的一个**分布式数据库**，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。**通过主机名最终得到该主机名对应的IP地址的过程叫做域名解析**（或主机名解析）。　　 

通俗地讲，我们更习惯于记住一个网站的名字，比如 www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像 http://www.baidu.com 等链接。因为，DNS就相当于一个电话本，比如你要找 http://www.baidu.com 这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。

### DNS有几种查询方式？
#### Answer
**两种：递归查询和迭代查询。**

* 递归解析

 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。
 
 ![](/images/dns递归查询.jpeg)
 
* 迭代解析

 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：http://baidu.com 的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。
 
 ![](/images/dns迭代查询.jpeg)
 
### 什么是DNS负载均衡？
#### Answer
当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。

###  什么是反向代理？
#### Answer
客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。

### 全球一共有多少台根域名服务器？
#### Answer
全球只有13台（这13台IPv4根域名服务器名字分别为“A”至“M”），1个为**主根服务器**在美国，由美国互联网机构Network Solutions运作。其余12个均为辅根服务器，其中9个在美国，2个在欧洲(位于英国和瑞典)，1个在亚洲(位于日本)。

### HTTP请求有哪些常见状态码？
#### Answer
HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：

|分类|分类描述|
|:---|:---|
|1xx|信息，服务器收到请求，需要请求者继续执行操作|
|2xx|成功，操作被成功接收并处理|
|3xx|重定向，需要进一步的操作以完成请求|
|4xx|客户端错误，请求包含语法错误或无法完成请求|
|5xx|服务器错误，服务器在处理请求的过程中发生了错误|
HTTP状态码列表：

|状态码|状态码英文名称	|中文描述
|:---|:---|:---|
|100|Continue|继续。客户端应继续其请求|
|101|Switching Protocols|切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议|
|200|OK|请求成功。一般用于GET与POST请求|
|201|Created|已创建。成功请求并创建了新的资源|
|202|Accepted|已接受。已经接受请求，但未处理完成|
|203|Non-Authoritative Information|非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本|
|204|No Content|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档|
|205|Reset Content|重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域|
|206|Partial Content|部分内容。服务器成功处理了部分GET请求|
|300|Multiple Choices|多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择|
|301|Moved Permanently|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|
|302|Found|临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI|
|303|See Other|查看其它地址。与301类似。使用GET和POST请求查看|
|304|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源|
|305|Use Proxy|使用代理。所请求的资源必须通过代理访问|
|306|Unused|已经被废弃的HTTP状态码|
|307|Temporary Redirect|临时重定向。与302类似。使用GET请求重定向|
|400|Bad Request|客户端请求的语法错误，服务器无法理解|
|401|Unauthorized|请求要求用户的身份认证|
|402|Payment Required|保留，将来使用|
|403|Forbidden|服务器理解请求客户端的请求，但是拒绝执行此请求|
|404|Not Found|服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面|
|405|Method Not Allowed|客户端请求中的方法被禁止|
|406|Not Acceptable|服务器无法根据客户端请求的内容特性完成请求|
|407|Proxy Authentication Required|请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权|
|408|Request Time-out|服务器等待客户端发送的请求时间过长，超时|
|409|Conflict|服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突|
|410|Gone|客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置|
|411|Length Required|服务器无法处理客户端发送的不带Content-Length的请求信息|
|412|Precondition Failed|客户端请求信息的先决条件错误|
|413|Request Entity Too Large|由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息|
|414|Request-URI Too Large|请求的URI过长（URI通常为网址），服务器无法处理|
|415|Unsupported Media Type|服务器无法处理请求附带的媒体格式|
|416|Requested range not satisfiable|客户端请求的范围无效|
|417|Expectation Failed|服务器无法满足Expect的请求头信息|
|500|Internal Server Error|服务器内部错误，无法完成请求|
|501|Not Implemented|服务器不支持请求的功能，无法完成请求|
|502|Bad Gateway|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
|503|Service Unavailabe|由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中|
|504|Gateway Time-out|充当网关或代理的服务器，未及时从远端服务器获取请求|
|505|HTTP Version not supported|服务器不支持请求的HTTP协议的版本，无法完成处理|

### 301 和 302 的区别？
#### Answer
301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。

他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；

302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO302好于301

### 什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？
#### Answer
每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。

（PS：RIP是应用层协议：https://www.zhihu.com/question/19645407 ）

**优缺点**

* 实现简单，开销小
* 随着网络规模扩大开销也会增大；
* 最大距离为15，限制了网络的规模；
* 当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器


数据库
---
### 数据库分为哪两种？
#### Answer
关系型 & 非关系型

关系型： 表

非关系型： 文档

### 关系型数据库和非关系型数据库的区别？
#### Answer
非关系型数据库的优势：
1. 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
2. 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

关系型数据库的优势：
1. 复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
2. 事务支持 使得对于安全性能很高的数据访问要求得以实现。

### 事务的概念和特性？
#### Answer
概念：数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束

特性（**ACID**）：

* **原子性**（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
* **一致性**（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；
* **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；
* **持久性**（Durability）：一旦事务提交成功，对数据的修改是永久性的

### 有哪些并发一致性问题？
#### Answer
* **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
* **脏读**（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
* **不可重复读**（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）；
* **幻读**（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据表整体/范围；并且针对insert/delete操作）

### 不可重复读和幻读的区别？
#### Answer
* 不可重复读是读取了其他事务更改的数据，针对update操作

 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

* 幻读是读取了其他事务新增的数据，针对insert和delete操作

 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

### 数据库的四种隔离级别？
#### Answer
* **未提交读**（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
* **提交读**（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；
* **可重复读**（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；（实现：MVCC）
* **可串行化**（序列化）（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。

### 什么是锁？
#### Answer
* **当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序**，锁机制就是这样的一个机制。

* 就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。

* 锁的作用：**用于管理对共享资源的并发访问，保证数据库的完整性和一致性。**

### 什么是乐观锁和悲观锁？
#### Answer
* **悲观锁：**认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于**数据更新比较频繁**的场景；
* **乐观锁：**操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于**读多写少**的场景。乐观锁的实现方式有：
    * 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；**（MVCC：多版本并发控制）**
    * 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新


### 封锁粒度的概念
#### Answer
MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。InnoDB 支持多粒度锁（multiple granularity locking），它**允许行级锁与表级锁共存**。

封锁粒度小：
* 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；
* 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）

### 常见的锁类型？
#### Answer
分为排他锁、共享锁和意向锁。

* **排它锁**（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
* **共享锁**（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁
* **意向锁**（Intention Locks）：
    * 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；
    * 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
    * IS/IX 锁之间都是兼容的；
    * 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了
![](/images/数据库基础1.png)

事务可以通过以下语句显式给记录集加共享锁或排他锁：

* 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 
* 排他锁（X)：`SELECT * FROM table_name WHERE ... FOR UPDATE`。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。

### 什么是意向锁？
#### Answer
**意向锁是一种不与行级锁冲突的表级锁,意向锁是有数据引擎自己维护的，用户无法手动操作意向锁**，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。意向锁分为两种：

* 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。

 ```sql
SELECT column FROM table ... LOCK IN SHARE MODE;
```

* 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。

 ```sql
SELECT column FROM table ... FOR UPDATE;
```

#### 意向锁的作用？
#### Answer
假设事务A获取了某一行的排他锁，但并未提交，此时事务B想获取整张表的表锁：

因为共享锁与排他锁互斥，所以事务 B 在试图对表加共享锁的时候，必须保证：

* 当前没有其他事务持有 users 表的排他锁。（表粒度）
* 当前没有其他事务持有 users 表中任意一行的排他锁 。（行粒度）

为了检测是否满足第二个条件，事务 B 必须在确保不存在任何表级排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了：

当事务A在操作某一行的排他锁时，同时获取了整张表的意向排他锁，而意向排他锁和**表级共享/排他锁
**是互斥的！也就不需要去检查每一行是否有排他锁，而只要检查整张表的意向锁就好了。

**注意！！！意向锁与行级锁不互斥！！！意向锁之间也不互斥！！！**

### 锁之间的兼容度？
||意向共享锁|意向排他锁|表级共享锁|表级排他锁|行级共享锁|行级排他锁|
|:---|:---|:---|:---|:---|:---|:---|
|意向共享锁|兼容|兼容|兼容|互斥|兼容|兼容|
|意向排他锁|兼容|兼容|互斥|互斥|兼容|兼容|
|表级共享锁|兼容|互斥|兼容|互斥|兼容|互斥|
|表级排他锁|互斥|互斥|互斥|互斥|互斥|互斥|
|行级共享锁|兼容|兼容|兼容|互斥|兼容|互斥|
|行级排他锁|兼容|兼容|互斥|互斥|互斥|互斥|

### 什么是三级封锁协议？
#### Answer
* 一级封锁协议

 * 一级封锁协议是：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。
 
 * 一级封锁协议可以防止**丢失修改**，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。

 * 在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。

* 二级封锁协议

 * 二级封锁协议是：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，**读完后方可释放S锁**。

 * 二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

* 三级封锁协议
 
 * 三级封锁协议是：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，**直到事务结束才释放**。

 * 三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了**不可重复读**。

上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。


### 什么是两段锁协议？
#### Answer
事务必须严格分为两个阶段对数据进行**加锁和解锁**的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

**可串行化调度**是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。
> 计算机系统对并发事务中并发操作的调度是随机的，而不同的调度可能会产生不同的结果。在计算机中，多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种调度策略为可串行化（Serializable）调度。

并发事务都**遵守两段锁协议**，则对这些事务的**任何并发调度策略**都是可串行化的 。

并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议 。

### 什么是 MVCC？
#### Answer
多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储**创建版本号**和**删除版本号**。
* **创建版本号：**创建一个数据行时的事务版本号（*事务版本号：*事务开始时的系统版本号；*系统版本号：*每开始一个新的事务，系统版本号就会自动递增）；
* **删除版本号：**删除操作时的事务版本号；
* 各种操作：
    * 插入操作时，记录创建版本号；
    * 删除操作时，记录删除版本号；
    * 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    * 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

### 什么是版本链？
#### Answer
我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：

trx_id这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。

roll_pointer每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)
![](/images/数据库基础2.png)

### ReadView
说了版本链我们再来看看ReadView。**已提交读和可重复读的区别就在于它们生成ReadView的策略不同。**

通过版本号减少了锁的争用，**提高了系统性能；**可以实现**提交读**和**可重复读**两种隔离级别，未提交读无需使用MVCC。

ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。

如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。

举个例子 ，在已提交读隔离级别下：

比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是
![](/images/数据库基础3.png)
那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。 这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。

那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务
![](/images/数据库基础4.png)
这时候版本链就是
![](/images/数据库基础5.png)
这时候之前那个select事务又执行了一次查询,又要查询id为1的记录。

**这个时候关键的地方来了**

如果你是**已提交读隔离级别，这时候你会重新一个ReadView，**那你的活动事务列表中的值就变了，变成了[110]。

按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。

如果你是**可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,**也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！

**也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。**

### 什么是快照读与当前读？
#### Answer
快照读(snapshot read)
使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：

简单的select操作(不包括 select ... lock in share mode, select ... for update)
```
select * from table ...;
```

当前读(current read)
更新数据时，都是先读后写，而这个读，就是当前读。当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：
```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```

### 数据库三大范式是什么？
#### Answer
1. 第一范式(确保每列保持原子性)

 第一范式是最基本的范式。如果数据库表中的**所有字段值都是不可分解的原子值**，就说明该数据库表满足了第一范式。
 
 第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。
 
 ![](/images/第一范式例子.png)
 
 上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。
 
2. 第二范式(确保表中的每列都和主键相关)

 第二范式在第一范式的基础之上更进一层。**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关**（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
 
 ![](/images/第二范式图1.png)
 
 这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。

 而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。

 ![](/images/第二范式图2.png)
 
 这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。
 
3. 第三范式(确保每列都和主键列直接相关,而不是间接相关)

  第三范式需要确保数据表中的**每一列数据都和主键直接相关，而不能间接相关**。

 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。
 
  ![](/images/第三范式图.png)
 
### 不符合范式会出现哪些异常？
#### Answer
* 冗余数据：某些同样的数据多次出现（如学生姓名）；
* 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；
* 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）；
* 插入异常：无法插入（插入一个还没有课程信息的学生）

### 表连接有几种方式？
#### Answer
![](/images/数据库基础6.png)
* **内连接**（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集
    * *自然连接：*只考虑属性相同的元组对；
    * *等值连接：*给定条件进行查询
* **外连接**（Outer Join）
    * *左连接：*左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；
    * *右连接：*和左连接相反；
    * *全外连接*（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据
* **交叉连接**（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）

### 什么是存储过程？有哪些优缺点？
#### Answer
存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。

优点：
* 预先编译，而不需要每次运行时编译，**提高了数据库执行效率；**
* 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以**减少网络通信量；**
* 具有**可复用性**，减少了数据库开发的工作量；
* **安全性高**，可以让没有权限的用户通过存储过程间接操作数据库；
* **更易于维护**

缺点：
* **可移植性差，**存储过程将应用程序绑定到了数据库上；
* **开发调试复杂：**没有好的IDE；
* **修改复杂，**需要重新编译，有时还需要更新程序中的代码以更新调用

### Drop/Delete/Truncate的区别？
#### Answer
* **Delete**用来删除表的全部或者部分数据，执行delete之后，用户**需要提交**之后才会执行，会触发表上的DELETE**触发器**（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；
* **Truncate**删除表中的所有数据，这个操作**不能回滚**，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
* **Drop**命令从数据库中**删除表**，所有的数据行，索引和约束都会被删除；**不能回滚，不会触发触发器；**

### 什么是触发器？
#### Answer
触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于**保证数据完整性**（比如可以检验或转换数据）。

### 有哪些约束类型？
#### Answer
约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。

### 什么是视图？什么是游标？
#### Answer
* 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：
    * 通过只给用户访问视图的权限，保证数据的**安全性**；
    * **简化**复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；
* 游标（Cursor）：用于定位在查询返回的**结果集的特定行**，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。

### 三级模式/二级映像
#### Answer
![](/images/数据库基础7.png)
![](/images/数据库基础8.png)

[^7]: InnoDB，是MySQL和MariaDB的数据库引擎之一，最初由MySQL AB发行。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。

### MySql三种核心日志是什么？
#### Answer
**Binlog、Undo Log 和 Redo Log。**

#### Undo Log
Undo Log的字面意思就是撤销操作的日志，指的是使MySQL中的数据回到某个状态。

在MySQL数据库中，事务开始之前，MySQL会将待修改的记录保存到Undo Log中，如果数据库崩溃或者事务需要回滚时，MySQL可以通过利用Undo Log日志，将数据库中的数据回滚到之前的状态。

MySQL新增、修改和删除数据时，在事务开始前，就会将信息写入Undo Log中。事务提交时，并不会立刻删除Undo Log，InnoDB存储引擎会将事务对应的Undo Log放入待删除列表中，之后会通过后台的purge thread对待删除的列表进行删除处理。**Undo Log是一种逻辑日志，记录的是一个变化过程。**比如，MySQL执行一个delete操作，Undo Log就会记录一个insert操作；MySQL执行一个insert操作，Undo Log就会记录一个delete操作；MySQL执行一个update操作，Undo Log就会记录一个相反的update操作。

**Undo Log实现了事务的原子性和多版本并发控制**，也就是我们经常说的MVCC。

#### Redo Log
Redo Log的字面意思就是重做日志，指的是在数据库出现意外情况时能够对重新执行某种操作。在MySQL中，事务中修改的任何数据，都会将最新的数据写入Redo Log中进行备份。
在MySQL中，随着事务操作的执行，就会产生Redo Log日志，在事务提交时会产生Redo Log并将其写入Redo Buffer，Redo Buffer也并不是随着事务的提交就会被立刻写入到磁盘中，而是等事务操作的脏页写入到磁盘之后，Redo Log的使命也就完成了，此时，Redo Log日志占用的空间可以重新利用，会被后续产生的Redo Log日志覆盖。

**Redo Log 能够实现事务的持久性**，防止在发生故障的时间点，有脏页未写入表的 ibd 文件中，在重启 MySQL 服务的时候，根据Redo Log进行重做，从而将未提交的事务进行持久化。

#### Binlog
Binlog记录所有MySQL数据库表结构变更以及表数据修改的二进制日志，不会记录select和show这类查询操作的日志。Binlog日志是以事件形式记录，还包含语句所执行的消耗时间。开启Binlog日志有以下两个最重要的使用场景:

* 主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。
* 数据恢复：通过mysql binlog等工具来恢复数据

### 数据库索引的实现原理？
#### Answer
**通常是B+树索引，偶尔也有哈希索引。**

在介绍B+树之前， 先简单的介绍一下B树。
#### B树概念
描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。

B树也称B-树,它是一颗多路平衡查找树。首先，B树和B+树都是从最简单的二叉树变换而来的，我们来看看B树的定义：
* 每个节点最多有m-1个**关键字**（可以存有的键值对）。
* 根节点最少可以只有1个**关键字**。
* 非根节点至少有m/2个**关键字**。
* 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
* 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
* 每个节点都存有索引和数据，也就是对应的key和value。

所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1。

#### B树插入
插入的时候，我们需要记住一个规则：**判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。**

例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。

* 插入18，70，50, 40
![](/images/mysql_Binsert1.png)
* 插入22
![](/images/mysql_Binsert2.png)
* 插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下
![](/images/mysql_Binsert3.png)
* 接着插入23，25，39
![](/images/mysql_Binsert4.png)
* 分裂，得到下面的
![](/images/mysql_Binsert5.png)

#### B树删除
B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。

例子：现在有一个初始状态是下面这样的B树，然后进行删除操作。
![](/images/mysql_Bremove1.png)
* 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。
![](/images/mysql_Bremove2.png)
![](/images/mysql_Bremove3.png)
* 接着，我们把22删除，这种情况的规则：22是非叶子节点，**对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。**对于删除22，需要将后继元素24移到被删除的22所在的节点。
![](/images/mysql_Bremove4.png)
![](/images/mysql_Bremove5.png)
* 此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：**如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。**这样就满足要求了。
![](/images/mysql_Bremove6.png)
![](/images/mysql_Bremove7.png)
* 接着删除28，删除叶子节点，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，**首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点。**
![](/images/mysql_Bremove8.png)
![](/images/mysql_Bremove9.png)

#### B+树
相同点：
* 根节点至少一个元素
* 非根节点元素范围：m/2 <= k <= m-1

不同点：
* B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
* 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
* 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
* 父节点存有右孩子的第一个元素的索引。

![](/images/mysql_Bplus.png)

#### 插入
对于插入操作很简单，只需要记住一个技巧即可：**当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。**

下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。

* 插入5，10，15，20
![](/images/mysql_Bplusinsert1.png)
* 插入25，此时元素数量大于4个了，分裂
![](/images/mysql_Bplusinsert2.png)
* 接着插入26，30，继续分裂
![](/images/mysql_Bplusinsert3.png)
![](/images/mysql_Bplusinsert4.png)

#### 删除
对于删除操作是比B树简单一些的，因为**叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，**下面我们看看具体的实例。
* 初始状态
![](/images/mysql_Bplusremove1.png)
* 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引
![](/images/mysql_Bplusremove2.png)
* 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引
![](/images/mysql_Bplusremove3.png)
* 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作
![](/images/mysql_Bplusremove4.png)

### B和B+树的区别？
#### Answer
B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。

#### B+ 树的优点
* B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
* 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。

#### B树的优点在于：
由于B树的每一个节点都包含key和value，因此如果经常访问的元素离根节点更近，这种情况下访问也更迅速：
![](/images/mysql5.png)

#### 使用B树和B+树的比较
InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
* IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；
* 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；
* 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

### 使用B树索引和哈希索引的比较
#### Answer
哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。

### 使用索引的优点
#### Answer
* 大大加快了数据的检索速度；
* 可以显著减少查询中分组和排序的时间；
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；
* 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

缺点：建立和维护索引耗费时间空间，更新索引很慢。

### 哪些情况下索引会失效？
#### Answer
* 以`%`(表示任意0个或多个字符)开头的LIKE语句；
* OR语句前后没有同时使用索引；
* 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；
* 对于多列索引，必须满足**最左匹配原则**/最左前缀原则 (最左优先：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
* 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

### 在哪些地方适合创建索引？
#### Answer
* 某列经常作为最大最小值；
* 经常被查询的字段；
* 经常用作表连接的字段；
* 经常出现在ORDER BY/GROUP BY/DISTINCT后面的字段

### 创建索引时需要注意什么？
#### Answer
* 只应建立在**小字段**上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；
* 建立索引的字段应该**非空**，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；
* 选择**数据密度大**（唯一值占总数的百分比很大）的字段作索引

### 索引的分类？
#### Answer
* **普通索引**
* **唯一索引** UNIQUE：索引列的值必须唯一，但允许有空值；
* **主键索引** PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；
* **单列索引和多列索引/复合索引**（Composite）：索引的列数；
* **覆盖（Covering）索引：**索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
* **聚集（Clustered）索引/非聚集索引：**对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；
* **虚拟索引（Virtual）：**模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用

### MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？
#### Answer
* InnoDB**支持事务**，可以进行Commit和Rollback；
* MyISAM 只支持表级锁，而 InnoDB 还**支持行级锁**，提高了并发操作的性能；
* InnoDB **支持外键**；
* MyISAM 崩溃后发生损坏的概率比 InnoDB **高**很多，而且恢复的速度也更**慢**；
* MyISAM 支持压缩表和空间数据索引，InnoDB需要更多的内存和存储；
* InnoDB 支持在线热备份

#### 应用场景
* **MyISAM**管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；
* **InnoDB**支持事务，并发情况下有很好的性能，基本可以替代MyISAM

### 什么是热备份和冷备份？
* **热备份：**在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错
* **冷备份：**数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单

### 如何优化数据库？
#### Answer
#### SQL 语句的优化
* 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL
* 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题；
* 应尽量避免在 where 子句中使用!=、<、>操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描；
* 只返回必要的列：最好不要使用 SELECT * 语句；
* 只返回必要的行：使用 LIMIT 语句来限制返回的数据；
* 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
    * 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；
    * 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；
    * 减少锁竞争

#### 索引的优化
注意会引起索引失效的情况，以及在适合的地方建立索引

#### 数据库表结构的优化
* 设计表时遵循**三大范式**；
* 选择合适的**数据类型**：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）；
* 表的**水平切分**（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；
* 表的**垂直切分**：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单

#### 系统配置的优化
* 操作系统：增加TCP支持的队列数；
* MySQL配置文件优化：缓存池大小和个数设置

#### 硬件的优化
* 磁盘性能：固态硬盘；
* CPU：多核且高频；
* 内存：增大内存

### 什么是主从复制？实现原理是什么？
#### Answer
主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。

实现原理：
* **主服务器 binary log dump 线程：**将主服务器中的数据更改（增删改）日志写入 Binary log 中；
* **从服务器 I/O 线程：**负责从主服务器读取binary log，并写入本地的 Relay log；
* **从服务器 SQL 线程：**负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性

### 为什么要主从复制？
#### Answer
* 读写分离：主服务器负责写，从服务器负责读
    * 缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；
    * 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
    * 增加冗余，提高可用性
* 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换
* 降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能






设计模式
---
### 工厂模式(Factory)
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；在创建简单对象时，建议直接new完成一个实例对象的创建。

#### 简单工厂模式
主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。

缺点：工厂类集中了所有产品类的创建逻辑，如果产品量较大，会使得工厂类变的非常臃肿。

```cpp
/*
关键代码：创建过程在工厂类中完成。
*/

#include <iostream>

using namespace std;

//定义产品类型信息
typedef enum
{
    Tank_Type_56,
    Tank_Type_96,
    Tank_Type_Num
}Tank_Type;

//抽象产品类
class Tank
{
public:
    virtual const string& type() = 0;
};

//具体的产品类
class Tank56 : public Tank
{
public:
    Tank56():Tank(),m_strType("Tank56")
    {
    }
    // 在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息。
    const string& type() override
    {
        cout << m_strType.data() << endl;
        return m_strType;
    }
private:
    string m_strType;
};

//具体的产品类
class Tank96 : public Tank
{
public:
    Tank96():Tank(),m_strType("Tank96")
    {
    }
    const string& type() override
    {
        cout << m_strType.data() << endl;
        return m_strType;
    }

private:
    string m_strType;
}; 

//工厂类
class TankFactory
{
public:
    //根据产品信息创建具体的产品类实例，返回一个抽象产品类
    Tank* createTank(Tank_Type type)
    {
        switch(type)
        {
        case Tank_Type_56:
            return new Tank56();
        case Tank_Type_96:
            return new Tank96();
        default:
            return nullptr;
        }
    }
};


int main()
{
    TankFactory* factory = new TankFactory();
    Tank* tank56 = factory->createTank(Tank_Type_56);
    tank56->type();
    Tank* tank96 = factory->createTank(Tank_Type_96);
    tank96->type();

    delete tank96;
    tank96 = nullptr;
    delete tank56;
    tank56 = nullptr;
    delete factory;
    factory = nullptr;

    return 0;
}
```

#### 工厂方法模式
定义一个创建对象的接口，其子类去具体现实这个接口以完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。

缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。

```cpp
/*
关键代码：创建过程在其子类执行。
*/

#include <iostream>

using namespace std;

//产品抽象类
class Tank
{
public:
    virtual const string& type() = 0;
};

//具体的产品类
class Tank56 : public Tank
{
public:
    Tank56():Tank(),m_strType("Tank56")
    {
    }

    const string& type() override
    {
        cout << m_strType.data() << endl;
        return m_strType;
    }
private:
    string m_strType;
};

//具体的产品类
class Tank96 : public Tank
{
public:
    Tank96():Tank(),m_strType("Tank96")
    {
    }
    const string& type() override
    {
        cout << m_strType.data() << endl;
        return m_strType;
    }

private:
    string m_strType;
}; 

//抽象工厂类，提供一个创建接口
class TankFactory
{
public:
    //提供创建产品实例的接口，返回抽象产品类
    virtual Tank* createTank() = 0;
};

//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例
class Tank56Factory : public TankFactory
{
public:
    Tank* createTank() override
    {
        return new Tank56();
    }
};

//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例
class Tank96Factory : public TankFactory
{
public:
    Tank* createTank() override
    {
        return new Tank96();
    }
};


int main()
{
    TankFactory* factory56 = new Tank56Factory();
    Tank* tank56 = factory56->createTank();
    tank56->type();
    
    TankFactory* factory96 = new Tank96Factory();
    Tank* tank96 = factory96->createTank();
    tank96->type();

    delete tank96;
    tank96 = nullptr;
    delete factory96;
    factory96 = nullptr;

    delete tank56;
    tank56 = nullptr;
    delete factory56;
    factory56 = nullptr;

    return 0;
}
```

#### 抽象工厂模式
抽象工厂模式提供创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

当存在多个产品系列，而客户端只使用一个系列的产品时，可以考虑使用抽象工厂模式。

缺点：当增加一个新系列的产品时，不仅需要现实具体的产品类，还需要增加一个新的创建接口，扩展相对困难。

```cpp
/*
* 关键代码：在一个工厂里聚合多个同类产品。
* 以下代码以白色衣服和黑色衣服为例，白色衣服为一个产品系列，黑色衣服为一个产品系列。白色上衣搭配白色裤子，   黑色上衣搭配黑色裤字。每个系列的衣服由一个对应的工厂创建，这样一个工厂创建的衣服能保证衣服为同一个系列。
*/

//抽象上衣类
class Coat
{
public:
    virtual const string& color() = 0;
};

//黑色上衣类
class BlackCoat : public Coat
{
public:
    BlackCoat():Coat(),m_strColor("Black Coat")
    {
    }

    const string& color() override
    {
        cout << m_strColor.data() << endl;
        return m_strColor;
    }
private:
    string m_strColor;
};

//白色上衣类
class WhiteCoat : public Coat
{
public:
    WhiteCoat():Coat(),m_strColor("White Coat")
    {
    }
    const string& color() override
    {
        cout << m_strColor.data() << endl;
        return m_strColor;
    }

private:
    string m_strColor;
}; 

//抽象裤子类
class Pants
{
public:
    virtual const string& color() = 0;
};

//黑色裤子类
class BlackPants : public Pants
{
public:
    BlackPants():Pants(),m_strColor("Black Pants")
    {
    }
    const string& color() override
    {
        cout << m_strColor.data() << endl;
        return m_strColor;
    }

private:
    string m_strColor;
};

//白色裤子类
class WhitePants : public Pants
{
public:
    WhitePants():Pants(),m_strColor("White Pants")
    {
    }
    const string& color() override
    {
        cout << m_strColor.data() << endl;
        return m_strColor;
    }

private:
    string m_strColor;
};

//抽象工厂类，提供衣服创建接口
class Factory
{
public:
    //上衣创建接口，返回抽象上衣类
    virtual Coat* createCoat() = 0;
    //裤子创建接口，返回抽象裤子类
    virtual Pants* createPants() = 0;
};

//创建白色衣服的工厂类，具体实现创建白色上衣和白色裤子的接口
class WhiteFactory : public Factory
{
public:
    Coat* createCoat() override
    {
        return new WhiteCoat();
    }

    Pants* createPants() override
    {
        return new WhitePants();
    }
};

//创建黑色衣服的工厂类，具体实现创建黑色上衣和白色裤子的接口
class BlackFactory : public Factory
{
    Coat* createCoat() override
    {
        return new BlackCoat();
    }

    Pants* createPants() override
    {
        return new BlackPants();
    }
};
```

### 单例模式(Singleton)
单例模式顾名思义，保证一个类仅可以有一个实例化对象，并且提供一个可以访问它的全局接口。实现单例模式必须注意以下几点：

* 单例类只能由一个实例化对象。
* 单例类必须自己提供一个实例化对象。
* 单例类必须提供一个可以访问唯一实例化对象的接口。

单例模式分为**懒汉**和**饿汉**两种实现方式。

#### 懒汉单例模式
懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化一个对象。在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，这是以时间换空间。

##### 非线程安全的懒汉单例模式
```cpp
/*
* 关键代码：构造函数是私有的，不能通过赋值运算，拷贝构造等方式实例化对象。
*/

//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要delete
class Singleton
{
public:
    static Singleton* getInstance();
    ~Singleton(){}

private:
    Singleton(){}                                        //构造函数私有
    Singleton(const Singleton& obj) = delete;            //明确拒绝
    Singleton& operator=(const Singleton& obj) = delete; //明确拒绝
    
    static Singleton* m_pSingleton; // 静态(static)成员: 不是任意对象的组成部分,但由给定类的全体对象所共享的数据成员或函数成员。
};

Singleton* Singleton::m_pSingleton = NULL;

Singleton* Singleton::getInstance()
{
    if(m_pSingleton == NULL)
    {
        m_pSingleton = new Singleton;
    }
    return m_pSingleton;
}
```

##### 线程安全的懒汉单例模式
```cpp
std::mutex mt;

class Singleton
{
public:
    static Singleton* getInstance();
private:
    Singleton(){}                                    //构造函数私有
    Singleton(const Singleton&) = delete;            //明确拒绝
    Singleton& operator=(const Singleton&) = delete; //明确拒绝

    static Singleton* m_pSingleton;
    
};
Singleton* Singleton::m_pSingleton = NULL;

Singleton* Singleton::getInstance()
{
    if(m_pSingleton == NULL)
    {
        mt.lock();
        if(m_pSingleton == NULL)
        {
            m_pSingleton = new Singleton();
        }
        mt.unlock();
    }
    return m_pSingleton;
}
```

##### 返回一个reference指向local static对象
这种单例模式实现方式多线程可能存在不确定性：任何一种non-const static对象，不论它是local或non-local,在多线程环境下“等待某事发生”都会有麻烦。解决的方法：在程序的单线程启动阶段手工调用所有reference-returning函数。这种实现方式的好处是不需要去delete它。
```cpp
class Singleton
{
public:
    static Singleton& getInstance();
private:
    Singleton(){}
    Singleton(const Singleton&) = delete;  //明确拒绝
    Singleton& operator=(const Singleton&) = delete; //明确拒绝
};


Singleton& Singleton::getInstance()
{
    static Singleton singleton;
    return singleton;
}
```

#### 饿汉单例模式
饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。
```cpp
//饿汉式：线程安全，注意一定要在合适的地方去delete它
class Singleton
{
public:
    static Singleton* getInstance();
private:
    Singleton(){}                                    //构造函数私有
    Singleton(const Singleton&) = delete;            //明确拒绝
    Singleton& operator=(const Singleton&) = delete; //明确拒绝

    static Singleton* m_pSingleton;
};

Singleton* Singleton::m_pSingleton = new Singleton();

Singleton* Singleton::getInstance()
{
    return m_pSingleton;
}
```

### 外观模式(Facade)
外观模式：为子系统中的一组接口定义一个一致的界面；外观模式提供一个高层的接口，这个接口使得这一子系统更加容易被使用；对于复杂的系统，系统为客户端提供一个简单的接口，把负责的实现过程封装起来，客户端不需要连接系统内部的细节。

以下情形建议考虑外观模式：
* 设计初期阶段，应有意识的将不同层分离，层与层之间建立外观模式。
* 开发阶段，子系统越来越复杂，使用外观模式提供一个简单的调用接口。
* 一个系统可能已经非常难易维护和扩展，但又包含了非常重要的功能，可以为其开发一个外观类，使得新系统可以方便的与其交互。

优点：
* 实现了子系统与客户端之间的松耦合关系。
* 客户端屏蔽了子系统组件，减少了客户端所需要处理的对象数据，使得子系统使用起来更方便容易。
* 更好的划分了设计层次，对于后期维护更加的容易。
```cpp
/*
* 关键代码：客户与系统之间加一个外观层，外观层处理系统的调用关系、依赖关系等。
*以下实例以电脑的启动过程为例，客户端只关心电脑开机的、关机的过程，并不需要了解电脑内部子系统的启动过程。
*/
#include <iostream>

using namespace std;

//抽象控件类，提供接口
class Control
{
public:
    virtual void start() = 0;
    virtual void shutdown() = 0;
};

//子控件， 主机
class Host : public Control
{
public:
    void start() override
    {
        cout << "Host start" << endl;
    }
    void shutdown() override
    {
        cout << "Host shutdown" << endl;
    }
};

//子控件， 显示屏
class LCDDisplay : public Control
{
public:
    void start() override
    {
        cout << "LCD Display start" << endl;
    }
    void shutdown() override
    {
        cout << "LCD Display shutdonw" << endl;
    }
};

//子控件， 外部设备
class Peripheral : public Control
{
public:
    void start() override
    {
        cout << "Peripheral start" << endl;
    }
    void shutdown() override
    {
        cout << "Peripheral shutdown" << endl;
    }
};

class Computer
{
public:
    void start()
    {
        m_host.start();
        m_display.start();
        m_peripheral.start();
        cout << "Computer start" << endl;
    }
    void shutdown()
    {
        m_host.shutdown();
        m_display.shutdown();
        m_peripheral.shutdown();
        cout << "Computer shutdown" << endl;
    }
private:
    Host   m_host;
    LCDDisplay m_display;
    Peripheral   m_peripheral;
};

int main()
{
    Computer computer;
    computer.start();

    //do something

    computer.shutdown();

    return 0;
}
```

### 模板模式(Template)
模板模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

当多个类有相同的方法，并且逻辑相同，只是细节上有差异时，可以考虑使用模板模式。具体的实现上可以将相同的核心算法设计为模板方法，具体的实现细节有子类实现。

缺点:每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

以生产电脑为例，电脑生产的过程都是一样的，只是一些装配的器件可能不同而已。
```cpp
/*
* 关键代码：在抽象类实现通用接口，细节变化在子类实现。
*/

#include <iostream>

using namespace std;

class Computer
{
public:
    void product()
    {
        installCpu();
        installRam();
        installGraphicsCard();
    }

protected:
    virtual void installCpu() = 0;
    virtual void installRam() = 0;
    virtual void installGraphicsCard() = 0;

};

class ComputerA : public Computer
{
protected:
    void installCpu() override
    {
        cout << "ComputerA install Inter Core i5" << endl;
    }

    void installRam() override
    {
        cout << "ComputerA install 2G Ram" << endl;
    }

    void installGraphicsCard() override
    {
        cout << "ComputerA install Gtx940 GraphicsCard" << endl;
    }
};

class ComputerB : public Computer
{
protected:
    void installCpu() override
    {
        cout << "ComputerB install Inter Core i7" << endl;
    }

    void installRam() override
    {
        cout << "ComputerB install 4G Ram" << endl;
    }

    void installGraphicsCard() override
    {
        cout << "ComputerB install Gtx960 GraphicsCard" << endl;
    }
};

int main()
{
    ComputerB* c1 = new ComputerB();
    c1->product();

    delete c1;
    c1 = nullptr;

    return 0;
}
```

### 组合模式(Composite)
组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得客户端对单个对象和组合对象的使用具有一直性。

既然讲到以树形结构表示“部分-整体”，那可以将组合模式想象成一根大树，将大树分成树枝和树叶两部分，树枝上可以再长树枝，也可以长树叶，树叶上则不能再长出别的东西。

以下情况可以考虑使用组合模式：

* 希望表示对象的部分-整体层次结构。
* 希望客户端忽略组合对象与单个对象的不同，客户端将统一的使用组合结构中的所有对象。

```cpp
/*
* 关键代码：树枝内部组合该接口，并且含有内部属性list，里面放Component。
*/

#include <iostream>
#include <list>
#include <memory>

using namespace std;

//抽象类，提供组合和单个对象的一致接口
class Company
{
public:
    Company(const string& name): m_name(name){}
    virtual ~Company(){ cout << "~Company()" << endl;}

    virtual void add(Company* ) = 0;
    virtual void remove(const string&) = 0;
    virtual void display(int depth) = 0;

    virtual const string& name()
    {
        return m_name;
    }

protected:
    string m_name;
};

//具体的单个对象实现类，“树枝”类
class HeadCompany : public Company
{
public:
    HeadCompany(const string& name): Company(name){}
    virtual ~HeadCompany(){ cout << "~HeadCompany()" << endl;}

    void add(Company* company) override
    {
        shared_ptr<Company> temp(company);
        m_companyList.push_back(temp);
    }

    void remove(const string& strName) override
    {
        list<shared_ptr<Company>>::iterator iter = m_companyList.begin();
        for(; iter != m_companyList.end(); iter++)
        {
            if((*iter).get()->name() == strName)
            {
            //不应该在此处使用list<T>.erase(list<T>::iterator iter),会导致iter++错误，这里删除目               标元素之后，必须return。
                m_companyList.erase(iter);
                return;
            }
        }
    }

    void display(int depth) override
    {
        for(int i = 0; i < depth; i++)
        {
            cout << "-";
        }
        cout << this->name().data() << endl;
        list<shared_ptr<Company>>::iterator iter = m_companyList.begin();
        for(; iter!= m_companyList.end(); iter++)
        {
            (*iter).get()->display(depth + 1);
        }
    }

private:
    list<shared_ptr<Company>> m_companyList;
};

//具体的单个对象实现类，“树叶”类
class ResearchCompany : public Company
{
public:
    ResearchCompany(const string& name): Company(name){}
    virtual ~ResearchCompany(){ cout << "~ResearchCompany()" << endl;}

    void add(Company* ) override
    {
    }

    void remove(const string&) override
    {
    }

    void display(int depth) override
    {
        for(int i = 0; i < depth; i++)
        {
            cout << "-";
        }
        cout << m_name.data() << endl;
    }
};

//具体的单个对象实现类，“树叶”类
class SalesCompany : public Company
{
public:
    SalesCompany(const string& name): Company(name){}
    virtual ~SalesCompany(){ cout << "~SalesCompany()" << endl;}

    void add(Company* ) override
    {
    }

    void remove(const string&) override
    {
    }

    void display(int depth) override
    {
        for(int i = 0; i < depth; i++)
        {
            cout << "-";
        }
        cout << m_name.data() << endl;
    }
};

//具体的单个对象实现类，“树叶”类
class FinanceCompany : public Company
{
public:
    FinanceCompany(const string& name): Company(name){}
    virtual ~FinanceCompany(){ cout << "~FinanceCompany()" << endl;}

    void add(Company* ) override
    {
    }

    void remove(const string&) override
    {
    }

    void display(int depth) override
    {
        for(int i = 0; i < depth; i++)
        {
            cout << "-";
        }
        cout << m_name.data() << endl;
    }
};


int main()
{
    HeadCompany* headRoot = new HeadCompany("Head Root Company");

    HeadCompany* childRoot1 = new HeadCompany("Child Company A");
    ResearchCompany* r1 = new ResearchCompany("Research Company A");
    SalesCompany* s1 = new SalesCompany("Sales Company A");
    SalesCompany* s2 = new SalesCompany("Sales Company B");
    FinanceCompany* f1 = new FinanceCompany("FinanceCompany A");
    
    childRoot1->add(r1);
    childRoot1->add(s1);
    childRoot1->add(s2);
    childRoot1->add(f1);

    HeadCompany* childRoot2 = new HeadCompany("Child Company B");
    ResearchCompany* r2 = new ResearchCompany("Research Company B");
    SalesCompany* s3 = new SalesCompany("Sales Company C");
    SalesCompany* s4 = new SalesCompany("Sales Company D");
    FinanceCompany* f2 = new FinanceCompany("FinanceCompany B");
    
    childRoot2->add(r2);
    childRoot2->add(s3);
    childRoot2->add(s4);
    childRoot2->add(f2);

    headRoot->add(childRoot1);
    headRoot->add(childRoot2);
    headRoot->display(1);
    
    cout << "\n***************\n" << endl;

    childRoot1->remove("Sales Company B");
    headRoot->display(1);
    
    cout << "\n***************\n" << endl;

    delete headRoot;
    headRoot = nullptr;

    return 0;
}
```

### 代理模式
代理模式：为其它对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。

优点：
* 职责清晰。真实的角色只负责实现实际的业务逻辑，不用关心其它非本职责的事务，通过后期的代理完成具体的任务。这样代码会简洁清晰。
* 代理对象可以在客户端和目标对象之间起到中介的作用，这样就保护了目标对象。
* 扩展性好。

```cpp
/*
* 关键代码：一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理*         类再访问真正要访问的对象。
*/
#include <iostream>

using namespace std;

class Gril
{
public:
    Gril(const string& name = "gril"):m_string(name){}
    string getName()
    {
        return m_string;
    }
private:
    string m_string;
};

class Profession
{
public:
    virtual ~Profession(){}
    virtual void profess() = 0;
};

class YoungMan : public Profession
{
public:
    YoungMan(const Gril& gril):m_gril(gril){}
    void profess()
    {
        cout << "Young man love " << m_gril.getName().data() << endl;
    }

private:
    Gril m_gril;
};

class ManProxy : public Profession
{
public:
    ManProxy(const Gril& gril):m_pMan(new YoungMan(gril)){}
    ~ManProxy()
    {
        delete m_pMan;
        m_pMan = nullptr;
    }
    void profess()
    {
        m_pMan->profess();
    }
private:
    YoungMan* m_pMan;
};

int main(int argc, char *argv[])
{
    Gril gril("heihei");
    ManProxy* proxy = new ManProxy(gril);
    proxy->profess();

    delete proxy;
    proxy = nullptr;
    return 0;
}
```

### 观察者模式(Observer)
观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都要得到通知并自动更新。

观察者模式从根本上讲必须包含两个角色：观察者和被观察对象。
* 被观察对象自身应该包含一个容器来存放观察者对象，当被观察者自身发生改变时通知容器内所有的观察者对象自动更新。
* 观察者对象可以注册到被观察者的中，完成注册后可以检测被观察者的变化，接收被观察者的通知。当然观察者也可以被注销掉，停止对被观察者的监控。

```cpp
/*
* 关键代码：在目标类中增加一个ArrayList来存放观察者们。
*/
#include <iostream>
#include <list>
#include <memory>

using namespace std;

class View;

//被观察者抽象类   数据模型
class DataModel
{
public:
    virtual ~DataModel(){}
    virtual void addView(View* view) = 0;
    virtual void removeView(View* view) = 0;
    virtual void notify() = 0;   //通知函数
};

//观察者抽象类   视图
class View
{
public:
    virtual ~View(){ cout << "~View()" << endl; }
    virtual void update() = 0;
    virtual void setViewName(const string& name) = 0;
    virtual const string& name() = 0;
};

//具体的被观察类， 整数模型
class IntDataModel:public DataModel
{
public:
    ~IntDataModel()
    {
        m_pViewList.clear();
    }

    virtual void addView(View* view) override
    {
        shared_ptr<View> temp(view);
        auto iter = find(m_pViewList.begin(), m_pViewList.end(), temp);
        if(iter == m_pViewList.end())
        {
            m_pViewList.push_front(temp);
        }
        else
        {
            cout << "View already exists" << endl;
        }
    }

    void removeView(View* view) override
    {
        auto iter = m_pViewList.begin();
        for(; iter != m_pViewList.end(); iter++)
        {
            if((*iter).get() == view)
            {
                m_pViewList.erase(iter);
                cout << "remove view" << endl;
                return;
            }
        }
    }

    virtual void notify() override
    {
        auto iter = m_pViewList.begin();
        for(; iter != m_pViewList.end(); iter++)
        {
            (*iter).get()->update();
        }
    }

private:
    list<shared_ptr<View>> m_pViewList; 
};

//具体的观察者类    表视图
class TableView : public View
{
public:
    TableView() : m_name("unknow"){}
    TableView(const string& name) : m_name(name){}
    ~TableView(){ cout << "~TableView(): " << m_name.data() << endl; }

    void setViewName(const string& name)
    {
        m_name = name;
    }

    const string& name()
    {
        return m_name;
    }

    void update() override
    {
        cout << m_name.data() << " update" << endl;
    }

private:
    string m_name;
};

int main()
{
    /*
    * 这里需要补充说明的是在此示例代码中，View一旦被注册到DataModel类之后，DataModel解析时会自动解析掉     * 内部容器中存储的View对象，因此注册后的View对象不需要在手动去delete，再去delete View对象会出错。
    */
    
    View* v1 = new TableView("TableView1");
    View* v2 = new TableView("TableView2");
    View* v3 = new TableView("TableView3");
    View* v4 = new TableView("TableView4");

    IntDataModel* model = new IntDataModel;
    model->addView(v1);
    model->addView(v2);
    model->addView(v3);
    model->addView(v4);

    model->notify();

    cout << "-------------\n" << endl;

    model->removeView(v1);

    model->notify();

    delete model;
    model = nullptr;

    return 0;
}
```

### 策略模式(Strategy)
策略模式是指定义一系列的算法，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而变化，也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色环境角色表现出不同的行为。

相比于使用大量的if...else，使用策略模式可以降低复杂度，使得代码更容易维护。

缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。

[环境角色] 持有一个策略类的引用，最终给客户端调用。

#### 传统的策略模式实现
```cpp
/*
* 关键代码：实现同一个接口。
* 以下代码实例中，以游戏角色不同的攻击方式为不同的策略，游戏角色即为执行不同策略的环境角色。
*/

#include <iostream>

using namespace std;

//抽象策略类，提供一个接口
class Hurt
{
public:
    virtual void blood() = 0;
};

//具体的策略实现类，具体实现接口， Adc持续普通攻击
class AdcHurt : public Hurt
{
public:
    void blood() override
    {
        cout << "Adc hurt, Blood loss" << endl;
    }
};

//具体的策略实现类，具体实现接口， Apc技能攻击
class ApcHurt : public Hurt
{
public:
    void blood() override
    {
        cout << "Apc Hurt, Blood loss" << endl;
    }
};

//环境角色类， 游戏角色战士，传入一个策略类指针参数。
class Soldier
{
public:
    Soldier(Hurt* hurt):m_pHurt(hurt)
    {
    }
    //在不同的策略下，该游戏角色表现出不同的攻击
    void attack()
    {
        m_pHurt->blood();
    }
private:
    Hurt* m_pHurt;
};

//定义策略标签
typedef enum
{
    Hurt_Type_Adc,
    Hurt_Type_Apc,
    Hurt_Type_Num
}HurtType;

//环境角色类， 游戏角色法师，传入一个策略标签参数。
class Mage
{
public:
    Mage(HurtType type)
    {
        switch(type)
        {
        case Hurt_Type_Adc:
            m_pHurt = new AdcHurt();
            break;
        case Hurt_Type_Apc:
            m_pHurt = new ApcHurt();
            break;
        default:
            break;
        }
    }
    ~Mage()
    {
        delete m_pHurt;
        m_pHurt = nullptr;
        cout << "~Mage()" << endl;
    }

    void attack()
    {
        m_pHurt->blood();
    }
private:
    Hurt* m_pHurt;
};

//环境角色类， 游戏角色弓箭手，实现模板传递策略。
template<typename T>
class Archer
{
public:
    void attack()
    {
        m_hurt.blood();
    }
private:
    T m_hurt;
};

int main()
{
    Archer<ApcHurt>* arc = new Archer<ApcHurt>;
    arc->attack();

    delete arc;
    arc = nullptr;
    
    return 0;
}
```

#### 使用函数指针实现策略模式
```cpp
#include <iostream>
#include <functional> 

void adcHurt()
{
    std::cout << "Adc Hurt" << std::endl;
}

void apcHurt()
{
    std::cout << "Apc Hurt" << std::endl;
}

//环境角色类， 使用传统的函数指针
class Soldier
{
public:
    typedef void (*Function)();
    Soldier(Function fun): m_fun(fun)
    {
    }
    void attack()
    {
        m_fun();
    }
private:
    Function m_fun;
};

//环境角色类， 使用std::function<>
class Mage
{
public:
    typedef std::function<void()> Function;

    Mage(Function fun): m_fun(fun)
    {
    }
    void attack()
    {
        m_fun();
    }
private:
    Function m_fun;
};

int main()
{
    Soldier* soldier = new Soldier(apcHurt);
    soldier->attack();
    delete soldier;
    soldier = nullptr;
    return 0;
}
```

### 建造者模式(Builder)
建造者模式：将复杂对象的构建和其表示分离，使得相同的构建过程可以产生不同的表示。

以下情形可以考虑使用建造者模式：
* 对象的创建复杂，但是其各个部分的子对象创建算法一定。
* 需求变化大，构造复杂对象的子对象经常变化，但将其组合在一起的算法相对稳定。

建造者模式的优点：
* 将对象的创建和表示分离，客户端不需要了解具体的构建细节。
* 增加新的产品对象时，只需要增加其具体的建造类即可，不需要修改原来的代码，扩展方便。

产品之间差异性大，内部变化较大、较复杂时不建议使用建造者模式。
```cpp
/*
*关键代码：建造者类：创建和提供实例； Director类：管理建造出来的实例的依赖关系。
*/

#include <iostream>
#include <string>

using namespace std;

//具体的产品类
class Order
{
public:
    void setFood(const string& food)
    {
        m_strFood = food;
    }

    const string& food()
    {
        cout << m_strFood.data() << endl;
        return m_strFood;
    }
    
    void setDrink(const string& drink)
    {
        m_strDrink = drink;
    }

    const string& drink()
    {
        cout << m_strDrink << endl;
        return m_strDrink;
    }

private:
    string m_strFood;
    string m_strDrink;
};

//抽象建造类，提供建造接口。
class OrderBuilder
{
public:
    virtual ~OrderBuilder()
    {
        cout << "~OrderBuilder()" << endl;
    }
    virtual void setOrderFood() = 0;
    virtual void setOrderDrink() = 0;
    virtual Order* getOrder() = 0;
};

//具体的建造类
class VegetarianOrderBuilder : public OrderBuilder 
{
public:
    VegetarianOrderBuilder()
    {
        m_pOrder = new Order;
    }

    ~VegetarianOrderBuilder()
    {
        cout << "~VegetarianOrderBuilder()" << endl;
        delete m_pOrder;
        m_pOrder = nullptr;
    }

    void setOrderFood() override
    {
        m_pOrder->setFood("vegetable salad");
    }

    void setOrderDrink() override
    {
        m_pOrder->setDrink("water");
    }

    Order* getOrder() override
    {
        return m_pOrder;
    }

private:
    Order* m_pOrder;
};

//具体的建造类
class MeatOrderBuilder : public OrderBuilder
{
public:
    MeatOrderBuilder()
    {
        m_pOrder = new Order;
    }
    ~MeatOrderBuilder()
    {
        cout << "~MeatOrderBuilder()" << endl;
        delete m_pOrder;
        m_pOrder = nullptr;
    }

    void setOrderFood() override
    {
        m_pOrder->setFood("beef");
    }

    void setOrderDrink() override
    {
        m_pOrder->setDrink("beer");
    }

    Order* getOrder() override
    {
        return m_pOrder;
    }

private:
    Order* m_pOrder;
};

//Director类，负责管理实例创建的依赖关系，指挥构建者类创建实例
class Director
{
public:
    Director(OrderBuilder* builder) : m_pOrderBuilder(builder)
    {
    }
    void construct()
    {
        m_pOrderBuilder->setOrderFood();
        m_pOrderBuilder->setOrderDrink();
    }

private:
    OrderBuilder* m_pOrderBuilder;
};


int main()
{
//  MeatOrderBuilder* mBuilder = new MeatOrderBuilder;
    OrderBuilder* mBuilder = new MeatOrderBuilder;  //注意抽象构建类必须有虚析构函数，解析时才会                                                      调用子类的析构函数
    Director* director = new Director(mBuilder);
    director->construct();
Order* order = mBuilder->getOrder();
order->food();
order->drink();

delete director;
director = nullptr;

delete mBuilder;
mBuilder = nullptr;

return 0;
}
```

### 适配器模式(Adapter)
适配器模式可以将一个类的接口转换成客户端希望的另一个接口，使得原来由于接口不兼容而不能在一起工作的那些类可以在一起工作。通俗的讲就是当我们已经有了一些类，而这些类不能满足新的需求，此时就可以考虑是否能将现有的类适配成可以满足新需求的类。适配器类需要继承或依赖已有的类，实现想要的目标接口。

缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

#### 使用复合实现适配器模式
```cpp
/*
* 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
* 以下示例中，假设我们之前有了一个双端队列，新的需求要求使用栈和队列来完成。
  双端队列可以在头尾删减或增加元素。而栈是一种先进后出的数据结构，添加数据时添加到栈的顶部，删除数据时先删   除栈顶部的数据。因此我们完全可以将一个现有的双端队列适配成一个栈。
*/

//双端队列， 被适配类
class Deque
{
public:
    void push_back(int x)
    {
        cout << "Deque push_back:" << x << endl;
    }
    void push_front(int x)
    {
        cout << "Deque push_front:" << x << endl;
    }
    void pop_back()
    {
        cout << "Deque pop_back" << endl;
    }
    void pop_front()
    {
        cout << "Deque pop_front" << endl;
    }
};

//顺序类，抽象目标类
class Sequence  
{
public:
    virtual void push(int x) = 0;
    virtual void pop() = 0;
};

//栈,后进先出, 适配类
class Stack:public Sequence   
{
public:
    //将元素添加到堆栈的顶部。
    void push(int x) override
    {
        m_deque.push_front(x);
    }
    //从堆栈中删除顶部元素
    void pop() override
    {
        m_deque.pop_front();
    }
private:
    Deque m_deque;
};

//队列，先进先出，适配类
class Queue:public Sequence  
{
public:
    //将元素添加到队列尾部
    void push(int x) override
    {
        m_deque.push_back(x);
    }
    //从队列中删除顶部元素
    void pop() override
    {
        m_deque.pop_front();
    }
private:
    Deque m_deque;
};
```

#### 使用继承实现适配器模式
```cpp
//双端队列，被适配类
class Deque  
{
public:
    void push_back(int x)
    {
        cout << "Deque push_back:" << x << endl;
    }
    void push_front(int x)
    {
        cout << "Deque push_front:" << x << endl;
    }
    void pop_back()
    {
        cout << "Deque pop_back" << endl;
    }
    void pop_front()
    {
        cout << "Deque pop_front" << endl;
    }
};

//顺序类，抽象目标类
class Sequence  
{
public:
    virtual void push(int x) = 0;
    virtual void pop() = 0;
};

//栈,后进先出, 适配类
class Stack:public Sequence, private Deque   
{
public:
    void push(int x)
    {
        push_front(x);
    }
    void pop()
    {
        pop_front();
    }
};

//队列，先进先出，适配类
class Queue:public Sequence, private Deque 
{
public:
    void push(int x)
    {
        push_back(x);
    }
    void pop()
    {
        pop_front();
    }
};
```

### 桥接模式(Bridge)
桥接模式：将抽象部分与实现部分分离，使它们都可以独立变换。

以下情形考虑使用桥接模式：
* 当一个对象有多个变化因素的时候，考虑依赖于抽象的实现，而不是具体的实现。
* 当多个变化因素在多个对象间共享时，考虑将这部分变化的部分抽象出来再聚合/合成进来。
* 当一个对象的多个变化因素可以动态变化的时候。

优点：
* 将实现抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则。
* 更好的可扩展性。
* 可动态的切换实现。桥接模式实现了抽象和实现的分离，在实现桥接模式时，就可以实现动态的选择具体的实现。
```cpp
/*
* 关键代码：将现实独立出来，抽象类依赖现实类。
* 以下示例中，将各类App、各类手机独立开来，实现各种App和各种手机的自由桥接。
*/
#include <iostream>

using namespace std;

//抽象App类，提供接口
class App
{
public:
    virtual ~App(){ cout << "~App()" << endl; }
    virtual void run() = 0;
};

//具体的App实现类
class GameApp:public App
{
public:
    void run()
    {
        cout << "GameApp Running" << endl;
    }
};

//具体的App实现类
class TranslateApp:public App
{
public:
    void run()
    {
        cout << "TranslateApp Running" << endl;
    }
};

//抽象手机类，提供接口
class MobilePhone
{
public:
    virtual ~MobilePhone(){ cout << "~MobilePhone()" << endl;}
    virtual void appRun(App* app) = 0;  //实现App与手机的桥接
};

//具体的手机实现类
class XiaoMi:public MobilePhone
{
public:
    void appRun(App* app)
    {
        cout << "XiaoMi: ";
        app->run();
    }
};

//具体的手机实现类
class HuaWei:public MobilePhone
{
public:
    void appRun(App* app)
    {
        cout << "HuaWei: ";
        app->run();
    }
};

int main()
{
    App* gameApp = new GameApp;
    App* translateApp = new TranslateApp;
    MobilePhone* mi = new XiaoMi;
    MobilePhone* hua = new HuaWei;
    mi->appRun(gameApp);
    mi->appRun(translateApp);
    hua->appRun(gameApp);
    hua->appRun(translateApp);

    delete hua;
    hua = nullptr;
    delete mi;
    mi = nullptr;
    delete gameApp;
    gameApp = nullptr;
    delete translateApp;
    translateApp = nullptr;

    return 0;
}
```

### 装饰模式(Decorator)
装饰模式：动态地给一个对象添加一些额外的功能，它是通过创建一个包装对象，也就是装饰来包裹真实的对象。新增加功能来说，装饰器模式比生产子类更加灵活。

以下情形考虑使用装饰模式：
* 需要扩展一个类的功能，或给一个类添加附加职责。
* 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。
* 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
* 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

```cpp
/*
* 关键代码：1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。
*/
#include <iostream>

using namespace std;

//抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。
class Component
{
public:
    virtual ~Component(){}

    virtual void configuration() = 0;
};

//具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。
class Car : public Component
{
public:
    void configuration() override
    {
        cout << "A Car" << endl;
    }
};

//装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。
class DecorateCar : public Component
{
public:
    DecorateCar(Component* car) : m_pCar(car){}

    void configuration() override
    {
        m_pCar->configuration();
    }

private:
    Component* m_pCar;
};

//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。
class DecorateLED : public DecorateCar
{
public:
    DecorateLED(Component* car) : DecorateCar(car){}

    void configuration() override
    {
        DecorateCar::configuration();
        addLED();
    }

private:
    void addLED()
    {
        cout << "Install LED" << endl;
    }

};

//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。
class DecoratePC : public DecorateCar
{
public:
    DecoratePC(Component* car) : DecorateCar(car){}

    void configuration() override
    {
        DecorateCar::configuration();
        addPC();
    }

private:
    void addPC()
    {
        cout << "Install PC" << endl;
    }
};

//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。
class DecorateEPB : public DecorateCar
{
public:
    DecorateEPB(Component* car) : DecorateCar(car){}

    void configuration() override
    {
        DecorateCar::configuration();
        addEPB();
    }

private:
    void addEPB()
    {
        cout << "Install Electrical Park Brake" << endl;
    }
};

int main()
{
    Car* car = new Car;
    DecorateLED* ledCar = new DecorateLED(car);
    DecoratePC* pcCar = new DecoratePC(ledCar);
    DecorateEPB* epbCar = new DecorateEPB(pcCar);

    epbCar->configuration();

    delete epbCar;
    epbCar = nullptr;

    delete pcCar;
    pcCar = nullptr;

    delete ledCar;
    ledCar = nullptr;

    delete car;
    car = nullptr;

    return 0;
}
```

### 中介者模式(Mediator)
中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之前的交互。

如果对象与对象之前存在大量的关联关系，若一个对象改变，常常需要跟踪与之关联的对象，并做出相应的处理，这样势必会造成系统变得复杂，遇到这种情形可以考虑使用中介者模式。当多个对象存在关联关系时，为它们设计一个中介对象，当一个对象改变时，只需要通知它的中介对象，再由它的中介对象通知每个与它相关的对象。
```cpp
/*
* 关键代码：将相关对象的通信封装到一个类中单独处理。
*/
#include <iostream>

using namespace std;

class Mediator;

//抽象同事类。
class Businessman
{
public:
    Businessman(){}
    Businessman(Mediator* mediator) : m_pMediator(mediator){}

    virtual ~Businessman(){}

    virtual void setMediator(Mediator* m)
    {
        m_pMediator = m;
    }

    virtual void sendMessage(const string& msg) = 0;
    virtual void getMessage(const string& msg) = 0;

protected:
    Mediator* m_pMediator;
};

//抽象中介者类。
class  Mediator
{
public:
    virtual ~Mediator(){}
    virtual void setBuyer(Businessman* buyer) = 0;
    virtual void setSeller(Businessman* seller) = 0;
    virtual void send(const string& msg, Businessman* man) = 0;
};

//具体同事类
class Buyer : public Businessman
{
public:
    Buyer() : Businessman(){}
    Buyer(Mediator* mediator) : Businessman(mediator){}

    void sendMessage(const string& msg) override
    {
        m_pMediator->send(msg, this);
    }

    void getMessage(const string& msg)
    {
        cout << "Buyer recv: " << msg.data() << endl;
    }
};

//具体同事类
class Seller : public Businessman
{
public:
    Seller() : Businessman(){}
    Seller(Mediator* mediator) : Businessman(mediator){}

    void sendMessage(const string& msg) override
    {
        m_pMediator->send(msg, this);
    }

    void getMessage(const string& msg)
    {
        cout << "Seller recv: " << msg.data() << endl;
    }
};

//具体中介者类
class HouseMediator : public Mediator
{
public:
    void setBuyer(Businessman* buyer) override
    {
        m_pBuyer = buyer;
    }

    void setSeller(Businessman* seller) override
    {
        m_pSeller = seller;
    }

    void send(const string& msg, Businessman* man) override
    {
        if(man == m_pBuyer)
        {
            m_pSeller->getMessage(msg);
        }
        else if(man == m_pSeller)
        {
            m_pBuyer->getMessage(msg);
        }
    }

private:
    Businessman* m_pBuyer;
    Businessman* m_pSeller;
};

int main()
{
    HouseMediator* hMediator = new HouseMediator;
    Buyer* buyer = new Buyer(hMediator);
    Seller* seller = new Seller(hMediator);

    hMediator->setBuyer(buyer);
    hMediator->setSeller(seller);

    buyer->sendMessage("Sell not to sell?");
    seller->sendMessage("Of course selling!");

    delete buyer;
    buyer = nullptr;

    delete seller;
    seller = nullptr;

    delete hMediator;
    hMediator = nullptr;


    return 0;
}
```

### 备忘录模式(Memento)
备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原来保存的状态。

备忘录模式中需要定义的角色类：
1. Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。
2. Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。
3. Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。
```cpp
/*
* 关键代码：Memento类、Originator类、Caretaker类；Originator类不与Memento类耦合，而是与Caretaker类耦合。
*/

include <iostream>

using namespace std;

//需要保存的信息
typedef struct  
{
    int grade;
    string arm;
    string corps;
}GameValue;

//Memento类
class Memento   
{
public:
    Memento(){}
    Memento(GameValue value):m_gameValue(value){}
    GameValue getValue()
    {
        return m_gameValue;
    }
private:
    GameValue m_gameValue;
};

//Originator类
class Game   
{
public:
    Game(GameValue value):m_gameValue(value)
    {}
    void addGrade()  //等级增加
    {
        m_gameValue.grade++;
    }
    void replaceArm(string arm)  //更换武器
    {
        m_gameValue.arm = arm;
    }
    void replaceCorps(string corps)  //更换工会
    {
        m_gameValue.corps = corps;
    }
    Memento saveValue()    //保存当前信息
    {
        Memento memento(m_gameValue);
        return memento;
    }
    void load(Memento memento) //载入信息
    {
        m_gameValue = memento.getValue();
    }
    void showValue()
    {
        cout << "Grade: " << m_gameValue.grade << endl;
        cout << "Arm  : " << m_gameValue.arm.data() << endl;
        cout << "Corps: " << m_gameValue.corps.data() << endl;
    }
private:
    GameValue m_gameValue;
};

//Caretaker类
class Caretake 
{
public:
    void save(Memento memento)  //保存信息
    {
        m_memento = memento;
    }
    Memento load()            //读已保存的信息
    {
        return m_memento;
    }
private:
    Memento m_memento;
};

int main()
{
    GameValue v1 = {0, "Ak", "3K"};
    Game game(v1);    //初始值
    game.addGrade();
    game.showValue();
    cout << "----------" << endl;
    Caretake care;
    care.save(game.saveValue());  //保存当前值
    game.addGrade();          //修改当前值
    game.replaceArm("M16");
    game.replaceCorps("123");
    game.showValue();
    cout << "----------" << endl;
    game.load(care.load());   //恢复初始值
    game.showValue();
    return 0;
}
```

### 原型模式(Prototype)
原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。通俗的讲就是当需要创建一个新的实例化对象时，我们刚好有一个实例化对象，但是已经存在的实例化对象又不能直接使用。这种情况下拷贝一个现有的实例化对象来用，可能会更方便。

以下情形可以考虑使用原型模式：
* 当new一个对象，非常繁琐复杂时，可以使用原型模式来进行复制一个对象。比如创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程。
* 当需要new一个新的对象，这个对象和现有的对象区别不大，我们就可以直接复制一个已有的对象，然后稍加修改。
* 当需要一个对象副本时，比如需要提供对象的数据，同时又需要避免外部对数据对象进行修改，那就拷贝一个对象副本供外部使用。
```cpp
/*
* 关键代码：拷贝，return new className(*this);
*/
#include <iostream>

using namespace std;

//提供一个抽象克隆基类。
class Clone
{
public:
    virtual Clone* clone() = 0;
    virtual void show() = 0;
};

//具体的实现类
class Sheep:public Clone
{
public:
    Sheep(int id, string name):Clone(),
                               m_id(id),m_name(name)
    {
        cout << "Sheep() id address:" << &m_id << endl;
        cout << "Sheep() name address:" << &m_name << endl;
    }
    ~Sheep()
    {
    }
    //关键代码拷贝构造函数
    Sheep(const Sheep& obj)
    {
        this->m_id = obj.m_id;
        this->m_name = obj.m_name;
        cout << "Sheep(const Sheep& obj) id address:" << &m_id << endl;
        cout << "Sheep(const Sheep& obj) name address:" << &m_name << endl;
    }
    //关键代码克隆函数，返回return new Sheep(*this)
    Clone* clone()
    {
        return new Sheep(*this);
    }
    void show()
    {
        cout << "id  :" << m_id << endl;
        cout << "name:" << m_name.data() << endl;
    }
private:
    int m_id;
    string m_name;
};

int main()
{
    Clone* s1 = new Sheep(1, "abs");
    s1->show();
    Clone* s2 = s1->clone();
    s2->show();
    
    delete s1;
    s1 = nullptr;
    delete s2;
    s2 = nullptr;
    return 0;
}
```

### 享元模式(Flyweight)
享元模式：运用共享技术有效地支持大量细粒度的对象。在有大量对象时，把其中共同的部分抽象出来，如果有相同的业务请求，直接返回内存中已有的对象，避免重新创建。

以下情况可以考虑使用享元模式：
*系统中有大量的对象，这些对象消耗大量的内存，且这些对象的状态可以被外部化。

对于享元模式，需要将对象的信息分为两个部分：内部状态和外部状态。内部状态是指被共享出来的信息，储存在享元对象内部且不随环境变化而改变；外部状态是不可以共享的，它随环境改变而改变，是由客户端控制的。
```cpp
/*
* 关键代码：将内部状态作为标识，进行共享。
*/
#include <iostream>
#include <map>
#include <memory>

using namespace std;

//抽象享元类，提供享元类外部接口。
class AbstractConsumer
{
public:
    virtual ~AbstractConsumer(){}
    virtual void setArticle(const string&) = 0;
    virtual const string& article() = 0;
};

//具体的享元类
class Consumer : public AbstractConsumer
{
public:
    Consumer(const string& strName) : m_user(strName){}
    ~Consumer()
    {
        cout << " ~Consumer()" << endl;
    }

    void setArticle(const string& info) override
    {
        m_article = info;
    }

    const string& article() override
    {
        return m_article;
    }

private:
    string m_user;
    string m_article;
};

//享元工厂类
class Trusteeship
{
public:
    ~Trusteeship()
    {
         m_consumerMap.clear();
    }

    void hosting(const string& user, const string& article)
    {
        if(m_consumerMap.count(user))
        {
            cout << "A customer named " << user.data() << " already exists" << endl;
            Consumer* consumer = m_consumerMap.at(user).get();
            consumer->setArticle(article);
        }
        else
        {
            shared_ptr<Consumer> consumer(new Consumer(user));
            consumer.get()->setArticle(article);
            m_consumerMap.insert(pair<string, shared_ptr<Consumer>>(user, consumer));
        }
    }

    void display()
    {
        map<string, shared_ptr<Consumer>>::iterator iter = m_consumerMap.begin();
        for(; iter != m_consumerMap.end(); iter++)
        {
            cout << iter->first.data() << " : "<< iter->second.get()->article().data() << endl;
        }
    }

private:
    map<string, shared_ptr<Consumer>> m_consumerMap;
};


int main()
{
    Trusteeship* ts = new Trusteeship;
    ts->hosting("zhangsan", "computer");
    ts->hosting("lisi", "phone");
    ts->hosting("wangwu", "watch");

    ts->display();

    ts->hosting("zhangsan", "TT");
    ts->hosting("lisi", "TT");
    ts->hosting("wangwu", "TT");

    ts->display();

    delete ts;
    ts = nullptr;

    return 0;
}
```

### 职责链模式(Chain of Resp.)
职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无需关心请求的处理细节和请求的传递，所有职责链将请求的发送者和请求的处理者解耦了。
```cpp
/*
* 关键代码：Handler内指明其上级，handleRequest()里判断是否合适，不合适则传递给上级。
*/
#include <iostream>

using namespace std;

enum RequestLevel
{
    Level_One = 0,
    Level_Two,
    Level_Three,
    Level_Num
};

//抽象处理者（Handler）角色，提供职责链的统一接口。
class Leader
{
public:
    Leader(Leader* leader):m_leader(leader){}
    virtual ~Leader(){}
    virtual void handleRequest(RequestLevel level) = 0;
protected:
    Leader* m_leader;
};

//具体处理者（Concrete Handler）角色
class Monitor:public Leader   //链扣1
{
public:
    Monitor(Leader* leader):Leader(leader){}
    void handleRequest(RequestLevel level)
    {
        if(level < Level_Two)
        {
            cout << "Mointor handle request : " << level << endl;
        }
        else
        {
            m_leader->handleRequest(level);
        }
    }
};

//具体处理者（Concrete Handler）角色
class Captain:public Leader    //链扣2
{
public:
    Captain(Leader* leader):Leader(leader){}
    void handleRequest(RequestLevel level)
    {
        if(level < Level_Three)
        {
            cout << "Captain handle request : " << level << endl;
        }
        else
        {
            m_leader->handleRequest(level);
        }
    }
};

//具体处理者（Concrete Handler）角色
class General:public Leader   //链扣3
{
public:
    General(Leader* leader):Leader(leader){}
    void handleRequest(RequestLevel level)
    {
        cout << "General handle request : " << level << endl;
    }
};

int main()
{
    Leader* general = new General(nullptr);
    Leader* captain = new Captain(general);
    Leader* monitor = new Monitor(captain);
    monitor->handleRequest(Level_One);

    delete monitor;
    monitor = nullptr;
    delete captain;
    captain = nullptr;
    delete general;
    general = nullptr;
    return 0;
}
```


算法
---
### LRU
#### 思路
hashmap加双向链表
#### Code
```cpp
#include <utility>
#include <list>
#include <unordered_map>

using namespace std;


class LRUCache {
public:
    LRUCache(int capacity) : cap(capacity) {}

    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        auto key_value = *map[key];
        cache.erase(map[key]);
        cache.push_front(key_value);
        map[key] = cache.begin();
        return key_value.second;
    }

    void put(int key, int value) {
        if (map.find(key) == map.end()) {
            if (cache.size() == cap) {
                map.erase(cache.back().first);
                cache.pop_back();
            }
        }
        else {
            cache.erase(map[key]);
        }
        cache.push_front({key, value});
        map[key] = cache.begin();
    }
private:
    int cap;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator> map;
};
```

### 快排
#### 思路
1. 取基准值
2. 比他小的放在左边，比他大的放右边
3. 递归对左右子数组快排

**可以通过随机取基准值和结合插入排序来优化**
#### Code
```cpp
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;

int partition(vector<int>& nums, int begin, int end) {
    int key = nums[end];
    int i = begin-1, j = begin;
    while (j < end) {
        if (nums[j] < key) {
            swap(nums[++i], nums[j]);
        }
        ++j;
    }
    swap(nums[++i], nums[end]);
    return i;
}

int randomPartition(vector<int>& nums, int begin, int end) {
    srand((unsigned) time(NULL));
    int r = (rand() % (end-begin+1)) + begin;
    swap(nums[r], nums[end]);
    return partition(nums, begin, end);
}

void quickSort(vector<int>& nums, int begin, int end) {
    if (begin >= end) return;
    int key = randomPartition(nums, begin, end);
    quickSort(nums, begin, key-1);
    quickSort(nums, key+1, end);
}
```

### 堆排序（从小到大）
```cpp
#include <vector>
#include <algorithm>

using namespace std;

void buildHeap(vector<int>& nums, int begin, int end) {
    int parent = begin;
    int child = parent * 2 + 1;
    while (child <= end) {
        if (child + 1 <= end && nums[child+1] > nums[child])
            child += 1;
        if (nums[parent] < nums[child]) {
            swap(nums[parent], nums[child]);
            parent = child;
            child = parent * 2 + 1;
        } else {
            return;
        }
    }
}

void heapSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = n/2 - 1; i >= 0; --i) {
        buildHeap(nums, i, n-1);
    }
    for (int i = n - 1; i > 0; --i) {
        swap(nums[i], nums[0]);
        buildHeap(nums, 0, i-1);
    }
}
```

### 插入排序
```cpp
#include <vector>

using namespace std;

void insertionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 1; i < n; ++i) {
        int j = i - 1;
        int key = nums[i];
        while (j >= 0 && nums[j] > key) {
            nums[j+1] = nums[j];
            --j;
        }
        nums[j+1] = key;
    }
}
```

Socket编程
---
### 什么是socket？
#### Answer
socket顾名思义就是套接字的意思，用于描述地址和端口，是一个通信链的句柄。**应用程序通过socket向网络发出请求或者回应。**也有人说，**socket就是用来建立三次握手的**。

### 有几种socket编程？
#### Answer
socket编程有三种，流式套接字（SOCK\_STREAM），数据报套接字(SOCK\_DGRAM)，原始套接字(SOCK\_RAW)，前两者较常用。**基于TCP的socket编程是流式套接字。**

### socket编程在TCP/IP模型的哪一层？
#### Answer
![](/images/socket抽象层.png)

### socket建立连接的过程？
#### Answer
![](/images/socket连接过程.png)
![](/images/socket连接过程1.png)

### socket需要哪些接口函数？
#### Answer
第一次握手：客户端需要发送一个syn X 包，试着去链接服务器端，于是在客户端我们需要提供一个链接函数。

第二次握手：服务器端需要接收客户端发送过来的syn X+1 包，然后在发送ack包，所以我们需要有服务器端接受处理函数

第三次握手：客户端的处理函数和服务器端的处理函数

三次握手只是一个数据传输的过程，但是，我们传输前需要一些准备工作，比如将创建一个套接字，收集一些计算机的资源，将一些资源绑定套接字里面，以及接受和发送数据的函数等等，这些功能接口在一起构成了socket的编程

### TCP简易编程
#### 服务器端
```cpp
#include<iostream>
#include<winsock.h>
#pragma comment(lib,"ws2_32.lib")
using namespace std;

/*初始化套接字库*/
void initialization() {
	WORD w_req = MAKEWORD(2,2);//版本号
	WSADATA wsadata;
	int err;
	err = WSAStartup(w_req,&wsadata);
	if (err != 0) {
		cout << "初始化套接字库失败！" << endl;
	}
	else {
		cout << "初始化套接字库成功！" << endl;
	}
	//检测版本号
	if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) {
		cout << "套接字库版本号不符！" << endl;
	}
	else {
		cout << "套接字库版本正确！" << endl;
	}
}

int main() {
	//定义长度变量
	int send_len = 0;
	int recv_len = 0;
	int len = 0;
	//定义发送缓冲区和接受缓冲区
	char send_buf[100];
	char recv_buf[100];
	//定义服务端套接字，接受请求套接字
	SOCKET s_server;
	SOCKET s_accept;
	//服务端地址客户端地址
	SOCKADDR_IN server_addr;
	SOCKADDR_IN accept_addr;
	initialization();
	//填充服务端信息
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
	server_addr.sin_port = htons(12341);
	//创建套接字
	s_server = socket(AF_INET,SOCK_STREAM,0);
	if (bind(s_server, (SOCKADDR*)&server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) {
		cout << "套接字绑定失败！" << endl;
		WSACleanup();
	}
	else {
		cout << "套接字绑定成功！" << endl;
	}
	//设置套接字为监听状态
	if (listen(s_server, SOMAXCONN) < 0) {
		cout << "设置监听失败！" << endl;
		WSACleanup();
	}
	else {
		cout << "设置监听成功！" << endl;
	}
	cout << "服务端正在监听连接，请稍等---" << endl;
	//接受连接请求
	len = sizeof(SOCKADDR);
	s_accept = accept(s_server, (SOCKADDR*)&accept_addr, &len);
	if (s_accept == SOCKET_ERROR) {
		cout << "连接失败！" << endl;
		WSACleanup();
		return 0;
	}
	cout << "连接建立，准备接受数据" << endl;
	//接受数据
	while (1) {
		recv_len = recv(s_accept,recv_buf,100,0);
		if (recv_len < 0) {
			cout << "接受失败！" << endl;
			break;
		}
		else {
			cout << "客户端信息：" << recv_buf << endl;
		}
		cout << "请输入回复信息：";
		cin >> send_buf;
		send_len = send(s_accept,send_buf,100,0);
		if (send_len < 0) {
			cout << "发送失败！" << endl;
			break;
		}
	}
	return 0;
}
```

#### 客户端
```cpp
#include<iostream>
#include<winsock.h>
#pragma comment(lib,"ws2_32.lib")
using namespace std;

void initialization() {
	//初始化套接字库
	WORD w_req = MAKEWORD(2,2);//版本号
	WSADATA wsadata;
	int err;
	err = WSAStartup(w_req,&wsadata);
	if (err != 0) {
		cout << "初始化套接字库失败!" << endl;
	}
	else {
		cout << "初始化套接字库成功！" << endl;
	}
	//检测版本号
	if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) {
		cout << "套接字库版本号不符！" << endl;
		WSACleanup();
	}
	else {
		cout << "套接字符版本号正确！" << endl;
	}
}
int main() {
	//定义长度变量
	int send_len = 0;
	int recv_len = 0;
	//定义发送缓冲区和接受缓冲区
	char send_buf[100];
	char recv_buf[100];
	//定义服务端套接字，接受请求套接字
	SOCKET s_server;
	//服务端地址客户端地址
	SOCKADDR_IN server_addr;
	initialization();
	//填充服务端信息
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	server_addr.sin_port = htons(12341);
	//创建套接字
	s_server = socket(AF_INET, SOCK_STREAM, 0);
	if (connect(s_server, (SOCKADDR*)&server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) {
		cout << "服务器连接失败！" << endl;
		WSACleanup();
	}
	else {
		cout << "服务器连接成功！" << endl;
	}
	//发送数据
	while (1) {
		cout << "请输入发送信息：" << endl;
		cin >> send_buf;
		send_len = send(s_server, send_buf, 100, 0);
		if (send_len < 0) {
			cout << "发送失败！" << endl;
			break;
		}
		recv_len = recv(s_server,recv_buf,100,0);
		if (recv_len < 0) {
			cout << "接受失败！" << endl;
			break;
		}
		else {
			cout << "服务端信息：" << recv_buf << endl;
		}
	}
	//关闭套接字
	closesocket(s_server);
	//释放DLL资源
	WSACleanup();
	return 0;
}
```