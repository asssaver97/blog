---
title: 【面经】闪思面试（八股+算法）（2022/03/16）
date: 2022-03-16 16:22:35
tags: 面经
---
请讲出以下代码的输出结果，并解释a,b,g三个变量分别存放在内存的哪片区域。
---
```cpp
#include <iostream>

using namespace std;

int g;
int main() {
    int a;
    static float b;
    a += 1;
    b += 100;
    g += 200;

    cout<<a<<endl;
    cout<<b<<endl;
    cout<<g<<endl;
    return 0;
}
```
<!--more-->

**答：**b=100，g=200，a输出不明。原因：变量a为**局部变量**，储存在**栈**内，值必须由程序员初始化，变量g和变量b分别为**全局变量**和**静态变量**，存放在**全局/静态储存区**，编译器会自动初始化为零。

请讲出以下代码的输出结果，并说明引用和指针的区别。
---
```cpp
#include <iostream>

using namespace std;

void swap(int &r1, int &r2);

int main() {
    int num1 = 10;
    int num2 = 20;
    swap(num1, num2);
    cout<<num1<<" "<<num2<<endl;
}

void swap(int &r1, int &r2) {
    int temp = r1;
    r1 = r2;
    r2 = temp;
}
```

**答：**num1=20，num2=10。
引用和指针的区别与联系：
1. 引用只能在定义时初始化一次，之后不能改变指向其它变量（从一而终）；指针变量的值可变。
2. 引用必须指向有效的变量，指针可以为空。
3. sizeof指针对象和引用对象的意义不一样。sizeof引用得到的是所指向的变量的大小，而sizeof指针是对象地址的大小。
4. 指针和引用自增(++)自减(--)意义不一样。引用是指值自增，而指针的自增指的是指向下一段内存地址。
5. 相对而言，引用比指针更安全。

说明面向过程编程和面向对象编程的区别
---
面向过程是一种以过程为中心的编程思想，它首先分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，在使用时依次调用，是一种基础的顺序的思维方式。面向过程开发方式是对计算机底层结构的一层抽象，它将程序分为数据和操纵数据的操作两部分，其核心问题是数据结构和算法的开发和优化。常见的支持面向过程的编程语言有 C语言、COBOL 语言等。

面向对象是按人们认识客观世界的系统思维方式，采用基于对象（实体）的概念建立模型，模拟客观世界分析、设计、实现软件的编程思想，通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。

面向对象方法直接把所有事物都当作独立的对象，处理问题过程中所思考的不再主要是怎样用数据结构来描述问题，而是直接考虑重现问题中各个对象之间的关系。面向对象方法的基础实现中也包含面向过程的思想。常见的支持面向对象的编程语言有 C++ 语言、C＃ 语言、Java 语言等。

面向对象编程的三大特性是什么？
---
封装、继承、多态。多态的两个前提：继承和虚函数。

C++类的封装特性在编程中如何体现？这些设计有什么好处？
---
public、private、protected。更安全，可以让继承或者调用类时不能访问到不想被访问的成员变量和成员函数。

使用类定义了两个对象，请问类中的成员变量在内存中有几份？成员函数有几份？
---
两份成员变量，一份成员函数。

请讲一下this指针及其如何使用。
---
在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

主要作用：结合上一题，因为this是所有成员函数的隐含参数，所以即使成员函数只拷贝了一份，也可以确定是哪一个对象在调用该成员函数。
次要作用：当对象内部成员变量与形参同名时，可以加以区分。

构造函数是否可以重载？不同作用域中的函数名称和参数完全相同的两个函数，是不是重载？
---
构造函数可以，析构函数不可以。
不是，它们就只是没有任何关系的两个函数而已。

C++继承的方式分为哪几种？请说明，使用派生类定义一个对象时，基类和派生类的构造函数的调用顺序；该对象消亡时，基类和派生类的析构函数的调用顺序。析构函数的函数名如何写？
---
1. public、protected、private。作用就是继承时把基类public区域的内容转换成对应权限。
2. 基类构造函数->派生类构造函数->派生类析构函数->基类析构函数。
3. 构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个`~`符号。

请讲出以下代码的输出结果。输出结果是否符合预期？如果不符合，请对以下函数进行改造。请讲出C++是通过什么机制实现多态的。
---
```cpp
#include <iostream>

using namespace std;

//基类People
class People {
public:
    People(char *name, int age);
    void display();
protected:
    char *m_name;
    int m_age;
};

People::People(char *name, int age):m_name(name),m_age(age){}

void People::display() {
    cout<<m_name<<"今年"<<m_age<<"岁了，是个小学生。"<<endl;
}

//派生类Teacher
class Teacher: public People {
public:
    Teacher(char *name, int age, int salary);
    void display();
protected:
    int m_salary;
};

Teacher::Teacher(char *name, int age, int salary):People(name, age), m_salary(salary){}

void Teacher::display() {
  cout<<m_name<<"今年"<<m_age<<"岁了，是一名教师，每月有"<<m_salary<<"元的收入。"<<endl;
}

int main() {
    People *p = new People("宋佳", 10);
    p->display();
    p = new Teacher("李亮", 45, 10000);
    p->display();
    return 0;
}
```

**答：**运行结果：
```
宋佳今年10岁了，是个小学生。
李亮今年45岁了，是个小学生。
```
原因：多态需要虚函数！所以应该在`People`类的`display()`函数前加上`virtual`关键字。

请解释C++中浅拷贝和深拷贝的区别。
---
1. 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
2. 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

请说明C++中的模板类别，使用模板的好处，使用模板是要用到哪个关键字。
---
模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。

* 模板有两种类别：**函数模板**和**类模板**。

* 使用模板的好处就是能够让程序员编写与类型无关的代码。

格式：
```cpp
template <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)
{
    函数体
}
```

* 其中`template`和`class`是关键字，`class`可以用`typename`关键字代替。

例：
```cpp
template <typename T>
inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
} 
```

请说明以下代码中3个const各自的作用。
---
```cpp
template <class T> const std::string& function(const T*) const;
```
第一个const修饰函数返回值。Const 修饰返回值分三种情况：
1. const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。
2. const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
3. const 修饰返回的指针或者引用，是为了避免返回值被修改。

第二个const修饰参数传递。const 修饰函数参数可以分为三种情况：
1. const 修饰指针指向的内容，比如`const int *p = 8;`，则内容为不可变量。
2. const 修饰指针，比如`int* const p = &a;`，则指针为不可变量。
3. 结合1和2。

第三个const修饰类成员函数，其目的是防止成员函数修改被调用对象的值。默认在成员函数的第一个位置是this指针，如果在成员函数（只能是成员函数，要是类的静态函数或者是非成员函数就不可以在函数后面加上const）后面加const，则说明this指针的值是不可以修改的，只能读取。而如果函数里面试图改变成员变量的值，这样编辑器肯定是不允许的，所以会出现错误的。

C++有哪些临时变量
---
1. 当函数的返回值没有赋值给其他变量时，会产生临时变量
2. 类型转换时的中间变量

要访问容器的元素，需要通过什么？有哪些类型？
---
迭代器。
STL定义了五种迭代器。

|迭代器类别|说明|
|:---|:---|
|输入|从容器中读取元素。输入迭代器只能一次读入一个元素向前移动，输入迭代器只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列|
|输出|向容器中写入元素。输出迭代器只能一次一个元素向前移动。输出迭代器只支持一遍算法，统一输出迭代器不能两次遍历一个序列|
|正向|组合输入迭代器和输出迭代器的功能，并保留在容器中的位置|
|反向|组合正向迭代器和逆向迭代器的功能，支持多遍算法|
|随机访问|组合双向迭代器的功能与直接访问容器中任何元素的功能，即可向前向后跳过任意个元素|

请讲出STL中vector、map、unordered_map的用途。
---
map底层是红黑树，优点是有序，时间复杂度为O(logn)；unordered_map底层是哈希表，优点是搜索更快，时间复杂度为O(1)。其他略。

用C++实现一个单向链表，要求实现增加元素、获得元素、弹出元素的功能。
---
略。

用C++实现快排。
---
略。
