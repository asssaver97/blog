---
title: 【LeetCode刷题笔记】312.戳气球
date: 2022-02-28 17:41:09
tags: 算法
categories: 刷题笔记
---
题目
---
[**312.戳气球**](https://leetcode-cn.com/problems/burst-balloons/)

有`n`个气球，编号为`0`到`n - 1`，每个气球上都标有一个数字，这些数字存在数组`nums`中。

现在要求你戳破所有的气球。戳破第`i`个气球，你可以获得`nums[i - 1] * nums[i] * nums[i + 1]`枚硬币。 这里的`i - 1`和`i + 1`代表和`i`相邻的两个气球的序号。如果`i - 1`或`i + 1`超出了数组的边界，那么就当它是一个数字为`1`的气球。

求所能获得硬币的最大数量。

示例 1：
```
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```
示例 2：
```
输入：nums = [1,5]
输出：10
```

提示：
* `n == nums.length`
* `1 <= n <= 500`
* `0 <= nums[i] <= 100`
<!--more-->

题解
---
对于本题，最容易想到的方法应该是**回溯**，即遍历每一个气球，修改数组往下递归，再复原。但是此方法会超时，所以我们这里讨论**动态规划**。
第一个气球和最后一个气球的左/右边都没有气球了，直接处理会非常麻烦，所以我们先扩宽边界，在0和n+1位置处放上两个值为1的虚拟气球。
对于动态规划数组dp[i][j]，我们表示第i个气球与第j个气球之间的最大硬币数量（**开区间**）。于是我们可以定义动态规划要素了：
1. 初始状态：当`i>=j`时，`dp[i][j]=0`，因为i与j之间没有气球。
2. 终止状态：我们最终要求的是第0个气球和第i+1个气球中间的最大值（开区间），即`i==0&&j==n+1`。
3. 状态转移：我们需要**逆向思维！！！不考虑先戳破哪个气球，而是考虑最后戳破哪个气球**。假设最后戳破的是第k个气球（i<k<j），那么根据题目，所得硬币数应该是`dp[i][j]=dp[i][k]+dp[k][j]+nums[i]*nums[j]*nums[k]`。对于k的值，我们显然只需要遍历i+1～j-1即可！
4. 转移方向：已知最终状态在右上角，而dp[i][k]和dp[k][j]分别在dp[i][j]的左边和下面，因此，我们选择**从下往上，从左往右**。

代码
---
```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        nums.insert(nums.begin(), 1);
        nums.insert(nums.end(), 1);
        vector<vector<int>> dp(n+2, vector<int>(n+2, 0));
        for (int i = n; i >= 0; --i) {
            for (int j = i+1; j < n+2; ++j) {
                for (int k = i+1; k < j; ++k) {
                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]+nums[k]*nums[i]*nums[j]);
                }
            }
        }
        return dp[0][n+1];
    }
};
```
