---
title: 【计算机网络】应用层：HTTP和HTTPS
date: 2022-02-20 15:57:17
tags: 八股文
categories: 计算机网络
mathjax: true
---
HTTP协议的特点
---
HTTP协议客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据；

![](/images/http结构.png)

服务端响应response也由四个部分组成，分别是：响应行、响应头、空行、响应体。
<!--more-->

请求头部字段包括：

* Accept：能够接受的回应内容类型
* Accept-Charset：能够接受的字符集
* Accept-Encoding：能够接受的编码方式列表
* Connection：该浏览器想要优先使用的连接类型
* Date：发送该消息的日期和时间(按照 RFC 7231 中定义的"超文本传输协议日期"格式来发送)
* Host：服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略
* ……

响应头部字段包括：

* Age：这个对象在代理缓存中存在的时间，以秒为单位
* Access-Control-Allow-Origin：指定哪些网站可参与到跨来源资源共享过程中
* Accept-Patch：指定服务器支持的文件格式类型。
* Date
* Allow：对于特定资源有效的动作。针对HTTP/405这一错误代码而使用
* Connection
* ……



### HTTP请求方法
HTTP协议定义了多种请求方式，具体如下：
GET：**获取资源**，用来请求访问已被URI（统一资源标志符，和URL是包含和被包含的关系，URL是最常见的URI）识别的资源。
POST：用来**传输实体的主体**，虽然GET也可以实现，但是一般不用。
PUT：**传输文件**。但是鉴于PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般网站都不采用该方法。
HEAD：**获得报文首部**。和GET请求一样，只是不返回报文主体部分。
DELETE：**删除文件**。同样不带验证机制，存在安全性问题。
OPTIONS：**询问指定的请求URI支持哪些方法**。
TRACE：**追踪路径**，让Web服务器将之前的请求通信环回给客户端的方法。
CONNECT：要求在**与代理服务器通信时建立隧道**，实现隧道协议进行TCP通信。


HTTP和HTTPS有什么区别？
---
1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
3. HTTPS由于加密解密会带来更大的CPU和内存开销；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

Https的连接过程（即SSL建立连接过程）？
---
1. 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；
2. 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；
3. 客户端验证服务器的合法性，包括：证书是否过期，CA（证书颁发机构） 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；
4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；
5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。
总结：**非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。**

怎么确定用HTTP还是HTTPS？你访问的网站是如何自动切换到 HTTPS 的？
---
一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。解决方法是引入HSTS （HTTP 严格传输安全，HTTP Strict Transport Security）机制，用户浏览器在访问站点的时候强制使用HTTPS。
> 302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect）

HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？
---
攻击者在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误。

HTTPS因为增加了CA证书，可以在会话前通过证书验证证明通信的彼此就是所声称的人，因此可以防范中间人攻击。这种防范中间人攻击的前提是在HTTPs协议的双向认证上。如果仅仅实现了HTTPs的单向认证，如不验证客户端，只验证服务器，这种情况下还是不能抵御中间人攻击的，这种情况下就会出现**SSL剥离攻击（SSLTrip）**和**SSL劫持攻击**。

SSL剥离攻击剥离SSL协议，表现为用户和攻击者之间使用HTTP，攻击者和服务器之间使用https协议。
> 如何防止SSL剥离攻击？可以（1）在服务器上开启HSTS，使服务器只接收使用HTTPS的连接。（2）将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。

SSL劫持攻击表现为用户和攻击者之间使用攻击者伪造的CA证书使用其https协议进行通信，（其中重要的步骤是把burpsuit的CA根证书导入用户浏览器，这样用户浏览器就能信任假CA发给中间人的证书(即信任中间人burpsuit)，建立客户端和中间人之间的会话信道）。而攻击者和服务器之间使用真正的CA证书创建的对称秘钥进行加密，攻击者收到客户端信息先用前者会话秘钥解密，再使用后者之间的会话秘钥加密。这样使得客户端和服务器都以为是和真正的对方通信。
> 如何防止SSL劫持攻击？使用https双向认证

什么是对称加密、非对称加密？区别是什么？
---
* 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
* 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA
区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）

数字签名、报文摘要的原理
---
* 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。
* 摘要算法:MD5、SHA
> **MD5信息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致

GET与POST的区别？
---
1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；
> 幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同
2. GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；
3. 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；
4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；
6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制

Get和Head的区别
---
HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。

Session与Cookie的区别？
---
Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案

Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。
> 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。URL重写的技术来进行会话跟踪，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。Session是在服务端保存的一个数据结构，用来跟踪用户的状态；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

从输入网址到获得页面的过程 (包括DNS如何解析成IP)？
---
1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；
> CSS 中的“样式”就是指外观；JavaScript 是一种脚本语言，它在网页中的作用是控制 HTML 中的每一个元素
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

全球一共有多少台根域名服务器？
---
全球只有13台（这13台IPv4根域名服务器名字分别为“A”至“M”），1个为主根服务器在美国，由美国互联网机构Network Solutions运作。其余12个均为辅根服务器，其中9个在美国，2个在欧洲(位于英国和瑞典)，1个在亚洲(位于日本)。

HTTP请求有哪些常见状态码？
---
HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：

|分类|分类描述|
|:---|:---|
|1xx|信息，服务器收到请求，需要请求者继续执行操作|
|2xx|成功，操作被成功接收并处理|
|3xx|重定向，需要进一步的操作以完成请求|
|4xx|客户端错误，请求包含语法错误或无法完成请求|
|5xx|服务器错误，服务器在处理请求的过程中发生了错误|
HTTP状态码列表：

|状态码|状态码英文名称	|中文描述
|:---|:---|:---|
|100|Continue|继续。客户端应继续其请求|
|101|Switching Protocols|切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议|
|200|OK|请求成功。一般用于GET与POST请求|
|201|Created|已创建。成功请求并创建了新的资源|
|202|Accepted|已接受。已经接受请求，但未处理完成|
|203|Non-Authoritative Information|非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本|
|204|No Content|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档|
|205|Reset Content|重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域|
|206|Partial Content|部分内容。服务器成功处理了部分GET请求|
|300|Multiple Choices|多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择|
|301|Moved Permanently|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|
|302|Found|临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI|
|303|See Other|查看其它地址。与301类似。使用GET和POST请求查看|
|304|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源|
|305|Use Proxy|使用代理。所请求的资源必须通过代理访问|
|306|Unused|已经被废弃的HTTP状态码|
|307|Temporary Redirect|临时重定向。与302类似。使用GET请求重定向|
|400|Bad Request|客户端请求的语法错误，服务器无法理解|
|401|Unauthorized|请求要求用户的身份认证|
|402|Payment Required|保留，将来使用|
|403|Forbidden|服务器理解请求客户端的请求，但是拒绝执行此请求|
|404|Not Found|服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面|
|405|Method Not Allowed|客户端请求中的方法被禁止|
|406|Not Acceptable|服务器无法根据客户端请求的内容特性完成请求|
|407|Proxy Authentication Required|请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权|
|408|Request Time-out|服务器等待客户端发送的请求时间过长，超时|
|409|Conflict|服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突|
|410|Gone|客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置|
|411|Length Required|服务器无法处理客户端发送的不带Content-Length的请求信息|
|412|Precondition Failed|客户端请求信息的先决条件错误|
|413|Request Entity Too Large|由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息|
|414|Request-URI Too Large|请求的URI过长（URI通常为网址），服务器无法处理|
|415|Unsupported Media Type|服务器无法处理请求附带的媒体格式|
|416|Requested range not satisfiable|客户端请求的范围无效|
|417|Expectation Failed|服务器无法满足Expect的请求头信息|
|500|Internal Server Error|服务器内部错误，无法完成请求|
|501|Not Implemented|服务器不支持请求的功能，无法完成请求|
|502|Bad Gateway|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
|503|Service Unavailabe|由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中|
|504|Gateway Time-out|充当网关或代理的服务器，未及时从远端服务器获取请求|
|505|HTTP Version not supported|服务器不支持请求的HTTP协议的版本，无法完成处理|

什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？
---
每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。
（PS：RIP是应用层协议：https://www.zhihu.com/question/19645407 ）

**优缺点**
* 实现简单，开销小
* 随着网络规模扩大开销也会增大；
* 最大距离为15，限制了网络的规模；
* 当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器

