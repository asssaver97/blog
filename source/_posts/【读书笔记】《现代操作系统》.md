---
title: 【读书笔记】《现代操作系统》
date: 2022-03-24 14:59:54
tags: 读书笔记
categories: 操作系统
mathjax: true
---
引论
---
**操作系统**是用来管理计算机各个部件的一层软件。用户与之交互的程序，基于文本的通常称为**shell**，而基于图标的则称为**图形用户界面**（也就是**GUI**）。它们不是操作系统的一部分，只是适用操作系统来完成工作。

多数计算机有两种运行模式：**内核态**和**用户态**。

* 计算机软件中最基础的部分是**操作系统**，它运行在**内核态**（也称为**管态**、**核心态**）。在这个模式中，操作系统具有**对所有硬件的完全访问权**，可以执行机器能够运行的任何指令。
* 软件的其余部分运行在**用户态**下。在用户态下，只使用了机器指令中的一个子集。用户接口程序（shell或GUI）处于用户态的最底层，允许用户运行其他程序；用户态的上层时Web浏览器、电子邮件阅读器、音乐播放器等程序。**这些程序也大量使用操作系统。**

资源管理包括两种形式的**多路复用**：

* 时间复用。轮流使用CPU。
* 空间复用。每个客户都得到资源的一部分。

**CPU：**首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后读取、解码并执行下一条指令。

进程与线程
---
### 进程
**伪并行：**在某一个瞬间，CPU只能允许一个进程，但在一秒内，它可能运行多个进程，与**多处理器系统**区别。

**进程和程序的关系：**（比喻）一个计算机科学家为他的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，**做蛋糕的食谱就是程序（即用适当形式描述的算法）**，**计算机科学家就是处理器（CPU）**，而做蛋糕的各种原料就是输入数据。**进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和**。

现在假设计算机科学家的儿子哭着跑进来了，说他的头被一只蜜蜂蛰了。计算机科学加就记录下它照着食谱坐到哪了（保存进程的当前状态），然后拿出一本急救手册，按照其中的指示处理蛰伤。这里，处理机从一个进程（做蛋糕）切换到另一个优先级更高的进程（实施医疗救治），每个进程拥有各自的程序（食谱和急救手册）。当蜜蜂蛰伤处理完以后，这位计算机科学家又回来做蛋糕，从他离开时的那一步继续做下去。

这里的关键思想是：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。**单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。**

#### 进程的创建
4种主要事件会导致进程的创建：
1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化

进程分为**前台进程**和**后台进程**。**前台进程**也就是同用户（人类）交互并且替他们完成工作的那些进程；**后台进程**与特定的用户没有关系，但具有专门的功能，比如接受发来邮件的后台进程。停留在后台诸如电子邮件、Web页面、新闻、打印之类活动的进程称为**守护进程**。

在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。注意，**可写的内存是不可以被共享的！**

#### 进程的退出
进程的终止通常由下列条件引起：
1. 正常退出（自愿）
2. 出错退出（自愿）
3. 严重错误（非自愿）
4. 被其他进程杀死（非自愿）

#### 进程的状态
进程有三种状态：
1. 运行态（该时刻进程实际占用CPU）
2. 就绪态（可运行，但因为其他进程正在运行而暂时停止）
3. 阻塞态（除非某种外部事件发生，比如有效输入，否则进程不能运行）

#### 进程表
为了实现进程模型，操作系统维护着一张表格，即**进程表**。每个进程占用一个进程表项（**进程控制块**）。下图展示了典型进程表表项中的一些字段：

|进程管理|存储管理|文件管理|
|:---|:--|:--|
|寄存器|代码段指针|根目录|
|程序计数器|数据段指针|工作目录|
|程序状态字|堆栈段指针|文件描述符|
|堆栈指针||用户ID|
|进程状态||组ID|
|优先级|
|调度参数|
|进程ID|
|父进程|
|进程组|
|信号|
|进程开始时间|
|使用的CPU时间|
|子进程的CPU时间|
|下次定时器时间|

#### 多道程序设计模型
假设一个进程等待 I/O 操作的时间与其停留在内存中的时间比为 $p$，当内存中同时有 $n$ 个进程时，则所有 $n$ 个进程都在等待 I/O 的概率是 $p^n$。CPU的利用率为：

$$CPU利用率=1-p^n$$

比如进程花费 80% 的时间等待 I/O，为使CPU的浪费低于 10%，至少要有10个进程同时在内存中。

### 线程
需要线程的原因：

1. 在许多应用中发生着多种活动，其中某些活动会随着时间的推移被阻塞。通过将这些应用程序分解为可以准并行运行的多个顺序线程，程序设计模型会变得简单。
2. 由于线程比进程更轻量级，所以他们比进程更容易（即更快）创建，也更容易销毁。
3. 若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行的速度。
4. 在多CPU系统中，多线程是的真正的并行有了实现的可能。*例子见《现代操作系统》P55字处理软件。*

#### 构造服务器的三种方法
|模型|特性|
|:--|:--|
|多线程|并行性、阻塞系统调用|
|单线程进程|无并行性、阻塞系统调用|
|有限状态机|并行性、非阻塞系统调用、中断|

#### 经典的线程模型
进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。

进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也可以共享同样的全局变量。

|一个进程中所有线程共享的内容|每个线程自己的内容|
|:--|:--|
|地址空间|程序计数器|
|全局变量|寄存器|
|打开文件|堆栈|
|子进程|状态|
|即将发生的定时器||
|信号与信号处理程序||
|账户信息||

