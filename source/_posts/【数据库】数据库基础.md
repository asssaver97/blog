---
title: 【数据库】数据库基础
date: 2022-03-06 15:46:27
tags: 数据库
categories: 八股文
---
为什么需要数据库？
---
数据库之前常用存储数据方式：

1. 数组、集合 等数据结构，即存在**内存**中

  缺点：内存具有易失性，比如一断电数据就会丢失
  
2. 文件
  
  缺点：不好查询
  
数据库的优点：

1. 数据持久化
2. 统一管理，易于查询



数据库的两种类型
---
关系型 & 非关系型

关系型： 表

非关系型： 文档

事务的概念和特性？
---
概念：数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束

特性（ACID）：
* **原子性**（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；
* **一致性**（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；
* **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；
* **持久性**（Durability）：一旦事务提交成功，对数据的修改是永久性的
<!--more-->

会出现哪些并发一致性问题？
---
* **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
* **脏读**（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
* **不可重复读**（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）；
* **幻读**（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert/delete操作）

数据库的四种隔离级别？
---
* **未提交读**（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
* **提交读**（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；
* **可重复读**（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；
* **可串行化**（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。

什么是乐观锁和悲观锁？
---
* **悲观锁：**认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于**数据更新比较频繁**的场景；
* **乐观锁：**操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于**读多写少**的场景。乐观锁的实现方式有：
    * 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    * 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新

常见的封锁类型？
---
意向锁是`InnoDB`[^1]自动加的， 不需用户干预。对于`UPDATE`、`DELETE`和`INSERT`语句，`InnoDB`会自动给涉及数据集加排他锁（X)； 对于普通`SELECT`语句，`InnoDB`不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：`SELECT * FROM table_name WHERE ... FOR UPDATE`。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁
* **排它锁**（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
* **共享锁**（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁
* **意向锁**（Intention Locks）：
    * 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；
    * 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
    * IS/IX 锁之间都是兼容的；
    * 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了
![](/images/数据库基础1.png)
锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性
1. 意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。
2. 表级S锁和X、IX锁不兼容：因为上了表级S锁后，不允许其他事务再加X锁。
3. 表级X锁和 IS、IX、S、X不兼容：因为上了表级X锁后，会修改数据，所以即使是行级排他锁，因为表级锁定的行肯定包括行级锁定的行，所以表级X和IX、X都不兼容。：上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行。

封锁粒度的概念
---
MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

封锁粒度小：
* 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；
* 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）

MySQL加锁
```
SELECT ... LOCK In SHARE MODE;  //S
SELECT ... FOR UPDATE;			//X
```

什么是三级封锁协议？
---
* 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
* 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
* 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）

什么是两段锁协议？
---
事务必须严格分为两个阶段对数据进行**加锁和解锁**的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

**可串行化调度**是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。
> 计算机系统对并发事务中并发操作的调度是随机的，而不同的调度可能会产生不同的结果。在计算机中，多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种调度策略为可串行化（Serializable）调度。

并发事务都**遵守两段锁协议**，则对这些事务的**任何并发调度策略**都是可串行化的 。

并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议 。

什么是 MVCC？
---
多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储**创建版本号**和**删除版本号**。
* **创建版本号：**创建一个数据行时的事务版本号（*事务版本号：*事务开始时的系统版本号；*系统版本号：*每开始一个新的事务，系统版本号就会自动递增）；
* **删除版本号：**删除操作时的事务版本号；
* 各种操作：
    * 插入操作时，记录创建版本号；
    * 删除操作时，记录删除版本号；
    * 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    * 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）

### 版本链
我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：

trx_id这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。

roll_pointer每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)
![](/images/数据库基础2.png)

### ReadView
说了版本链我们再来看看ReadView。**已提交读和可重复读的区别就在于它们生成ReadView的策略不同。**

通过版本号减少了锁的争用，**提高了系统性能；**可以实现**提交读**和**可重复读**两种隔离级别，未提交读无需使用MVCC。

ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。

如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。

举个例子 ，在已提交读隔离级别下：

比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是
![](/images/数据库基础3.png)
那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。 这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。

那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务
![](/images/数据库基础4.png)
这时候版本链就是
![](/images/数据库基础5.png)
这时候之前那个select事务又执行了一次查询,又要查询id为1的记录。

**这个时候关键的地方来了**

如果你是**已提交读隔离级别，这时候你会重新一个ReadView，**那你的活动事务列表中的值就变了，变成了[110]。

按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。

如果你是**可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,**也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！

**也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。**

快照读与当前读
---
### 快照读(snapshot read)
使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：

简单的select操作(不包括 select ... lock in share mode, select ... for update)
```
select * from table ...;
```

### 当前读(current read)
更新数据时，都是先读后写，而这个读，就是当前读。当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：
````
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```

数据库的范式？
---
* **第一范式**（1NF，Normal Form）：**属性不应该是可分的**。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话...如果将“移动电话”作为一个属性，就符合1NF；
* **第二范式** 2NF：每个非主属性**完全依赖**于主属性集（候选键集）；
    * B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；
    * 主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；
    * 可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余； 满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；
* **第三范式** 3NF：在 2NF 的基础上，非主属性不传递依赖于主属性
    * 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；
    * 3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。 必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；

### 不符合范式会出现哪些异常？
* 冗余数据：某些同样的数据多次出现（如学生姓名）；
* 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；
* 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）；
* 插入异常：无法插入（插入一个还没有课程信息的学生）

列举几种表连接方式？
---
![](/images/数据库基础6.png)
* **内连接**（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集
    * *自然连接：*只考虑属性相同的元组对；
    * *等值连接：*给定条件进行查询
* **外连接**（Outer Join）
    * *左连接：*左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；
    * *右连接：*和左连接相反；
    * *全外连接*（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据
* **交叉连接**（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）

什么是存储过程？有哪些优缺点？
---
存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。

优点：
* 预先编译，而不需要每次运行时编译，**提高了数据库执行效率；**
* 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以**减少网络通信量；**
* 具有**可复用性**，减少了数据库开发的工作量；
* **安全性高**，可以让没有权限的用户通过存储过程间接操作数据库；
* **更易于维护**

缺点：
* **可移植性差，**存储过程将应用程序绑定到了数据库上；
* **开发调试复杂：**没有好的IDE；
* **修改复杂，**需要重新编译，有时还需要更新程序中的代码以更新调用

Drop/Delete/Truncate的区别？
---
* **Delete**用来删除表的全部或者部分数据，执行delete之后，用户**需要提交**之后才会执行，会触发表上的DELETE**触发器**（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；
* **Truncate**删除表中的所有数据，这个操作**不能回滚**，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
* **Drop**命令从数据库中**删除表**，所有的数据行，索引和约束都会被删除；**不能回滚，不会触发触发器；**

什么是触发器？
---
触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于**保证数据完整性**（比如可以检验或转换数据）。

有哪些约束类型？
---
约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。

什么是视图？什么是游标？
---
* 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：
    * 通过只给用户访问视图的权限，保证数据的**安全性**；
    * **简化**复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；
* 游标（Cursor）：用于定位在查询返回的**结果集的特定行**，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。

三级模式/二级映像
---
![](/images/数据库基础7.png)
![](/images/数据库基础8.png)

[^1]: InnoDB，是MySQL和MariaDB的数据库引擎之一，最初由MySQL AB发行。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。


